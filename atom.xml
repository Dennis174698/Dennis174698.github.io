<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dennis_Chen</title>
  
  <subtitle>愚人码头</subtitle>
  <link href="http://dennis174698.github.io/atom.xml" rel="self"/>
  
  <link href="http://dennis174698.github.io/"/>
  <updated>2021-07-30T09:13:54.548Z</updated>
  <id>http://dennis174698.github.io/</id>
  
  <author>
    <name>Dennis Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>crush</title>
    <link href="http://dennis174698.github.io/2021/07/16/crush/"/>
    <id>http://dennis174698.github.io/2021/07/16/crush/</id>
    <published>2021-07-15T16:02:37.000Z</published>
    <updated>2021-07-30T09:13:54.548Z</updated>
    
    <content type="html"><![CDATA[<p>冰川融化的第一滴水，<br>破晓前的第一声鸟叫，<br>森林里忽然落下的断枝，<br>夜空中划过了一颗流星。</p><p><img src="/image/flower.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;冰川融化的第一滴水，&lt;br&gt;破晓前的第一声鸟叫，&lt;br&gt;森林里忽然落下的断枝，&lt;br&gt;夜空中划过了一颗流星。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/flower.jpg&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂事" scheme="http://dennis174698.github.io/categories/%E6%9D%82%E4%BA%8B/"/>
    
    
    <category term="杂事" scheme="http://dennis174698.github.io/tags/%E6%9D%82%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发（二）</title>
    <link href="http://dennis174698.github.io/2021/07/01/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://dennis174698.github.io/2021/07/01/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-06-30T16:24:36.000Z</published>
    <updated>2021-06-30T16:26:24.870Z</updated>
    
    
    
    
    <category term="java" scheme="http://dennis174698.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://dennis174698.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java并发(一)</title>
    <link href="http://dennis174698.github.io/2021/06/03/Java%E5%B9%B6%E5%8F%91/"/>
    <id>http://dennis174698.github.io/2021/06/03/Java%E5%B9%B6%E5%8F%91/</id>
    <published>2021-06-02T16:00:35.000Z</published>
    <updated>2021-06-02T08:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h2><h3 id="1-1进程"><a href="#1-1进程" class="headerlink" title="1.1进程"></a>1.1进程</h3><ul><li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</li><li>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</li></ul><p><strong>进程通信</strong></p><ul><li><p><strong>进程通信</strong>：</p></li><li><p><strong>有名管道。</strong>也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p></li><li><p><strong>信号量(semaphore)。</strong>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p></li><li><p><strong>消息队列(messagequeue)。</strong>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p><strong>信号 (sinal)。</strong>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p></li><li><p><strong>共享内存(shared memory)。</strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p></li><li><p><strong>套接字(socket)。</strong>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p></li></ul><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h3><ul><li><p>线程是进程的一个实体，是CPU调度和分配的基本单位。进程是线程的容器，一个进程在运行时可能产生多个线程，一个进程下的线程共享进程所拥有的全部资源。</p></li><li><p><strong>线程通信</strong></p></li><li><p><strong>锁机制：</strong>包括互斥锁、条件变量、读写锁。互斥锁提供了以排他方式防止数据结构被并发修改的方法。读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。wait/notify 等待 。。Volatile 内存共享。。CountDownLatch 并发工具。。CyclicBarrier 并发工具</p></li><li><p><strong>信号量机制(Semaphore)。</strong> 包括无名线程信号量和命名线程信号量。</p></li><li><p><strong>信号机制(Signal)。</strong> 类似进程间的信号处理。</p></li><li><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p></li></ul><h3 id="1-3-线程与进程的区别"><a href="#1-3-线程与进程的区别" class="headerlink" title="1.3 线程与进程的区别"></a>1.3 线程与进程的区别</h3><ul><li>线程是比进程更轻量级的调度执行单位，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址，文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。</li><li>多进程中每个进程有自己的地址空间，线程则共享地址空间。</li><li>所有其他区别都是因为这个区别产生的。比如说：<ul><li>地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</li><li>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</li></ul></li><li>线程是处理器调度的基本单位,但进程不是</li><li>二者均可并发执行</li><li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</li><li>速度。线程产生的速度快，通讯快，切换快，因为他们处于同一地址空间。</li><li>线程的资源利用率好。</li><li>线程使用公共变量或者内存的时候需要同步机制，但进程不用。</li><li>而他们通信方式的差异也仍然是由于这个根本原因造成的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-进程与线程&quot;&gt;&lt;a href=&quot;#1-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;1. 进程与线程&quot;&gt;&lt;/a&gt;1. 进程与线程&lt;/h2&gt;&lt;h3 id=&quot;1-1进程&quot;&gt;&lt;a href=&quot;#1-1进程&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="http://dennis174698.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://dennis174698.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>集合类</title>
    <link href="http://dennis174698.github.io/2021/05/29/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>http://dennis174698.github.io/2021/05/29/%E9%9B%86%E5%90%88%E7%B1%BB/</id>
    <published>2021-05-29T08:08:00.000Z</published>
    <updated>2021-06-02T08:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-常用集合"><a href="#Java-常用集合" class="headerlink" title="Java 常用集合"></a>Java 常用集合</h1><p><img src="/image/java/jihe.png"></p><h2 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h2><h3 id="1-1-List基本实现"><a href="#1-1-List基本实现" class="headerlink" title="1.1 List基本实现"></a>1.1 List基本实现</h3><ul><li>ArrayList: List 主要实现类，底层使用Object[]存储，适合频繁查询工作，线程不安全</li><li>Vector: 古老实现类，线程安全，</li><li>LinkedList: 底层使用双向链表结构,JDK1.7取消了循环<ul><li>getFirst（） 和element（） 完全一样，都返回第一个元素。如果为空，抛NoSuchElementException.</li><li>peek（） 方法与上诉类似，只时列表为空返回null</li><li>removeFirst（） 和 remove（） 类似，移除并返回列表的头，只是列表为空抛出NoSuchElementException。</li><li>poll（） 同样移除并返回列表头，只是列表为空返回Null</li></ul></li><li>Stack: 栈结构,pop（）、push（）、 peek（）方法，其中peek（）返回栈顶元素，而不将其移除。</li></ul><h3 id="1-2-ArrayList扩容与源码分析"><a href="#1-2-ArrayList扩容与源码分析" class="headerlink" title="1.2 ArrayList扩容与源码分析"></a>1.2 ArrayList扩容与源码分析</h3><pre><code>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：   /**     * 默认初始容量大小     */    private static final int DEFAULT_CAPACITY = 10;    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;    /**     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)     */    public ArrayList() &#123;        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    &#125;    /**     * 带初始容量参数的构造函数。（用户自己指定容量）     */    public ArrayList(int initialCapacity) &#123;        if (initialCapacity &gt; 0) &#123;//初始容量大于0            //创建initialCapacity大小的数组            this.elementData = new Object[initialCapacity];        &#125; else if (initialCapacity == 0) &#123;//初始容量等于0            //创建空数组            this.elementData = EMPTY_ELEMENTDATA;        &#125; else &#123;//初始容量小于0，抛出异常            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                               initialCapacity);        &#125;    &#125;   /**    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回    *如果指定的集合为null，throws NullPointerException。    */     public ArrayList(Collection&lt;? extends E&gt; c) &#123;        elementData = c.toArray();        if ((size = elementData.length) != 0) &#123;            // c.toArray might (incorrectly) not return Object[] (see 6260652)            if (elementData.getClass() != Object[].class)                elementData = Arrays.copyOf(elementData, size, Object[].class);        &#125; else &#123;            // replace with empty array.            this.elementData = EMPTY_ELEMENTDATA;        &#125;    &#125;</code></pre><ul><li>无参初始化容量为10</li><li>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</li></ul><h3 id="1-3-LinkedList-源码"><a href="#1-3-LinkedList-源码" class="headerlink" title="1.3 LinkedList 源码"></a>1.3 LinkedList 源码</h3><p>定义了一个内部的Node 节点，基于双向链表实现，使用 Node 存储链表节点信息。<br>相关操作：</p><ul><li><p>getFirst() 和element() 完全一样，都返回第一个元素。如果为空，抛NoSuchElementException.</p></li><li><p>peek() 方法与上诉类似，只时列表为空返回null</p></li><li><p>removeFirst() 和 remove() 类似，移除并返回列表的头，只是列表为空抛出NoSuchElementException。</p></li><li><p>poll() 同样移除并返回列表头，只是列表为空返回Null</p><pre><code>private static class Node&lt;E&gt; &#123;      E item;      Node&lt;E&gt; next;      Node&lt;E&gt; prev;      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;          this.item = element;          this.next = next;          this.prev = prev;      &#125;  &#125;</code></pre></li><li><p>add（）方法有<strong>add（E e）</strong> 方法：将元素添加到链表尾部，<strong>add（int index,E e）</strong>：在指定位置添加元素</p></li><li><p><strong>addAll（Collection c ）</strong>：将集合插入到链表尾部,<strong>addAll（int index, Collection c）</strong>： 将集合从指定位置开始插入</p></li><li><p><strong>get(int index)：</strong> 根据指定索引返回数据,**int indexOf(Object o)**： 从头遍历找 **int lastIndexOf(Object o)**： 从尾遍历找, **remove(int index)**：删除指定位置的元素</p></li></ul><h3 id="1-4-ArrayList与LinkedList区别"><a href="#1-4-ArrayList与LinkedList区别" class="headerlink" title="1.4 ArrayList与LinkedList区别"></a>1.4 ArrayList与LinkedList区别</h3><p><strong>1. 是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）<br><strong>3. 插入和删除是否受元素位置的影响：</strong><br>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add（E e）方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O（1）。但是如果要在指定位置 i 插入和删除元素的话（add（int index, E element））时间复杂度就为 O（n-i）。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的（n-i）个元素都要执行向后位/向前移一位的操作。<br>LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add（E e）、addFirst（E e）、addLast（E e）、removeFirst（） 、 removeLast（）），近似 O（1），如果是要在指定位置 i 插入和删除元素的话（add（int index, E element），remove（Object o）） 时间复杂度近似为 O（n） ，因为需要先移动到指定位置再插入。<br><strong>4. 是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象（对应于get（int index）方法）。<br><strong>5. 内存空间占用：</strong> ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p><h2 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h2><ul><li>HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》</li><li>Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>ConcurrentHashMap: 线程安全的Map.</li><li>TreeMap: 基于红黑树的实现（自平衡的排序二叉树）。“键”或“键值对”的次序是由Comparable或Comparator决定的。TreeMap是唯一带有subMap()方法的Map，可以返回一个子树。</li><li>WeakHashMap： 弱键映射，允许设释放射所指对象。被垃圾收集器回收。</li><li>ConcurrentHashMap: 线程安全的Map.</li><li>IdentityHashMap：使用==代替equals()对“键”进行比较的散列映射。</li><li>sortedMap: 排序的Map，现阶段TreeMap是其唯一实现。</li><li>EnumMap:要求键必须来自一个Enum。</li></ul><h3 id="2-1-HashMap"><a href="#2-1-HashMap" class="headerlink" title="2.1 HashMap"></a>2.1 HashMap</h3><ul><li><strong>底层实现</strong><br>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。</li></ul><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 （n - 1） &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><pre><code>1.8 的hash方法    static final int hash(Object key) &#123;      int h;      // key.hashCode()：返回散列值也就是hashcode      // ^ ：按位异或      // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);  &#125;</code></pre><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;    // 序列号    private static final long serialVersionUID = 362498820763181265L;    // 默认的初始容量是16    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;    // 最大容量    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    // 默认的填充因子    static final float DEFAULT_LOAD_FACTOR = 0.75f;    // 当桶(bucket)上的结点数大于这个值时会转成红黑树    static final int TREEIFY_THRESHOLD = 8;    // 当桶(bucket)上的结点数小于这个值时树转链表    static final int UNTREEIFY_THRESHOLD = 6;    // 桶中结构转化为红黑树对应的table的最小大小    static final int MIN_TREEIFY_CAPACITY = 64;    // 存储元素的数组，总是2的幂次倍    transient Node&lt;k,v&gt;[] table;    // 存放具体元素的集    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;    // 存放元素的个数，注意这个不等于数组的长度。    transient int size;    // 每次扩容和更改map结构的计数器    transient int modCount;    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容    int threshold;    // 加载因子    final float loadFactor;&#125;</code></pre><ul><li><strong>loadFactor 加载因子</strong></li></ul><p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><ul><li><strong>threshold</strong></li></ul><p>threshold = capacity * loadFactor，当 Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</p><ul><li><strong>扩容</strong></li></ul><ol><li>计算扩容新的table长度size 与threshold 的长度</li><li>遍历旧table，如果节点，无哈希冲突的情况，e.hash&amp;(newCap-1)直接定位到新的位置。</li><li>出现哈希冲突的情况，由于每次扩容的大小默认为2的n次方，因此重散列的位置只会为当前位置或者当前位置+旧数组大小两个位置。</li><li>如果节点存在哈希冲突，则根据位运算计算最新的位置是否为0，为0表示无需移动节点。为1表示移动到oldCap+j的位置。</li><li>针对出现红黑树的哈希冲突，同理。此处针对红黑树冲突的需要判断重散列的节点是否需要重新建立红黑树。</li><li>如果初始化容量大小部位2的幂次方，那么在初始化的时候，会计算threshold为大于初始化数的最近2的幂次方数，在实际使用的时候声明为table的大小。※</li></ol><ul><li><strong>红黑树</strong></li></ul><p>红黑树： 红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。<br>三种操作：左旋、右旋和变色。</li></ul><p><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。<br><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。<br><strong>变色</strong>：结点的颜色由红变黑或由黑变红。 <a href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></p><p><img src="/image/java/rbtree.png"></p><ul><li><strong>put操作</strong></li></ul><ol><li>首先判断table是否需要扩容，若需要进行扩容操作</li><li>计算当前元素hash经过散列后是否有元素存在，若不存在元素直接添加。</li><li>若存在元素，分下面两个判断<br>替换：若旧元素的hash值与新添加元素一致，且新添加Node 的key调用equals方法一致，则直接替换旧节点。<br>拉链法：<br>普通链表：循环判断链表节点是否为key相同替换情况，若均不是需要替换情况，则定位到链表尾部添加新节点。<br>红黑树：树形遍历判断是否存在，不存在添加。</li></ol><ul><li><strong>hashmap红黑树查找</strong></li></ul><p><strong>为什么使用红黑树：</strong> 当HashMap中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候HashMap就相当于一个单链表，假如单链表有n个元素，遍历的时间复杂度就是O(n)，完全失去了它的优势。 针对这种情况，JDK1.8中引入了红黑树来优化这个问题，为什么不引入二叉查找树呢？因为二叉查找树的一般操作的执行时间为O(lgn)，但是二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。与单链表一样。 所以此时我们需要红黑树它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。<br>红黑树建立是基于Hash的大小来建立的。这里的hashcode 为hashMap换算过的hash。hash小的为左子树， hash 大的为右子树</p><p>针对hash重复的情况：</p><p>使用equal的方法进行匹配，相同返回。<br>若存在左节点或右节点缺失，则直接进入未缺失的节点查找。（left==null ==&gt; findByRight)，均不存在返回null。<br>左右子节点均存在，判断是否为相同的class，及class是否继承comparable接口，<br>若为相同的class且都继承则直接通过comparable判断左右节点。<br>若不同的class、无继承comparable接口或者经过comparable接口比较的结果相等。<br>递归调用左节点查找，若未找到，递归调用右节点查找。</p><pre><code> final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;    TreeNode&lt;K,V&gt; p = this;    do &#123;        int ph, dir; K pk;        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;        if ((ph = p.hash) &gt; h)            p = pl;        else if (ph &lt; h)            p = pr;        // hash 相同 使用equal比较        else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))            return p;        // 左右子树缺失，直接进入存在子树的部分        else if (pl == null)            p = pr;        else if (pr == null)            p = pl;        // 基于class的比较，若都继承comparable接口，则使用compareTo比较        // 若class 均不继承comparable 接口，或者compare接口比较后相同，进入左右子树递归查询。        else if ((kc != null ||                  (kc = comparableClassFor(k)) != null) &amp;&amp;                 (dir = compareComparables(kc, k, pk)) != 0)            p = (dir &lt; 0) ? pl : pr;        else if ((q = pr.find(h, k, kc)) != null)            return q;        else            p = pl;    &#125; while (p != null);    return null;&#125;</code></pre><p>针对建立红黑树或者添加树节点的情况</p><ul><li><p>若使用equal及class 的compare 均无法确定添加节点的方向</p></li><li><p>使用对象的类名进行判断，若类名依然相同，则使用System根据对象地址换算的hashcode编码判断添加方向。<br>static int tieBreakOrder(Object a, Object b) {</p><pre><code>  int d;  if (a == null || b == null ||      (d = a.getClass().getName().       compareTo(b.getClass().getName())) == 0)      d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?           -1 : 1);  return d;</code></pre><p>  }</p></li><li><p><strong>HashMap遍历方法</strong></p><ul><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历。</li></ul></li></ul><p>如果从性能方面考虑，我们应该尽量使用 lambda 或者是 entrySet 来遍历 Map 集合。</p><p>EntrySet 之所以比 KeySet 的性能高是因为，KeySet 在循环时使用了 map.get（key），而 map.get（key） 相当于又遍历了一遍 Map 集合去查询 key 所对应的值。为什么要用“又”这个词？那是因为在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用 map.get（key） 查询时，相当于遍历了两遍。<br>而 EntrySet 只遍历了一遍 Map 集合，之后通过代码“Entry&lt;Integer, String&gt; entry = iterator.next（）”把对象的 key 和 value 值都放入到了 Entry 对象中，因此再获取 key 和 value 值时就无需再遍历 Map 集合，只需要从 Entry 对象中取值就可以了。<br>所以，EntrySet 的性能比 KeySet 的性能高出了一倍，因为 KeySet 相当于循环了两遍 Map 集合，而 EntrySet 只循环了一遍。</p><p><a href="https://juejin.cn/post/6844904144331866119">https://juejin.cn/post/6844904144331866119</a></p><h3 id="2-2-concurrentHashMap"><a href="#2-2-concurrentHashMap" class="headerlink" title="2.2 concurrentHashMap"></a>2.2 concurrentHashMap</h3><ul><li>数据结构:synchronized+CAS+Node+红黑树,Node的val和next都用volatile修饰,保证可见性</li><li>查找,替换,赋值操作都使用CAS</li><li>锁:锁链表的head节点,不影响其他元素的读写,锁粒度更细,效率更高,扩容时,阻塞所有的读写<br>操作、并发扩容</li><li>读操作无锁:<br>Node的val和next使用volatile修饰,读写线程对该变量互相可见<br>数组用volatile修饰,保证扩容时被读线程感知</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-常用集合&quot;&gt;&lt;a href=&quot;#Java-常用集合&quot; class=&quot;headerlink&quot; title=&quot;Java 常用集合&quot;&gt;&lt;/a&gt;Java 常用集合&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/image/java/jihe.png&quot;&gt;&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="Java" scheme="http://dennis174698.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://dennis174698.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://dennis174698.github.io/2021/05/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://dennis174698.github.io/2021/05/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-05-28T13:17:51.000Z</published>
    <updated>2021-06-29T17:00:05.170Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/java/sort.png"></p><ul><li>相关资料：<a href="https://www.jianshu.com/p/47170b1ced23">https://www.jianshu.com/p/47170b1ced23</a></li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>比较相邻的元素，如果前一个比后一个大，交换两个元素</li><li>从最开始的一对到最后一对，这样最后的元素就是数组里最大的数</li><li>重复以上步骤，除了最后一个</li><li>重复步骤1-3，知道排序完成。</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#python实现</span><span class="token keyword">def</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> nums    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token keyword">return</span> nums        </code></pre><pre><code>//Java实现public static int[] bubbleSort(int[] nums)&#123;    n = nums.lengthl    if(n==0)&#123;return nums;&#125;    for(int i=0;i&lt;n;i++)&#123;    for(int j=0;j&lt;n-1-i;j++)&#123;        if(nums[j]&gt;nums[j+1])&#123;        int tmp = nums[j+1];        nums[j+1] = nums[j];        nums[j] = tmp;        &#125;    &#125;    &#125;&#125;</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>从未排序的序列中找到最大（小）元素，放入排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#python 实现</span><span class="token keyword">def</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> nums    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    minIndex <span class="token operator">=</span> i    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">:</span>        minIndex <span class="token operator">=</span> j    tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span>      <span class="token comment" spellcheck="true">#最小元素和无序区第一个数交换</span>    nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp    <span class="token keyword">return</span> nums</code></pre><pre><code>//java实现public static int[] selectSort(int[] nums)&#123;    n = nums.length;    if(n==0)&#123;return nums;&#125;    for(int i=0;i&lt;n;i++)&#123;    int minIndex=i;    for(int j=i;j&lt;n;j++)&#123;        if(nums[minIndex]&lt;nums[j])&#123;minIndex = j;&#125;            &#125;        int tmp=nums[minIndex];        nums[minIndex] = nums[i];        nums[i] = tmp;    &#125;    return nums;&#125;</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>直接插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>一般来说，直接插入排序都采用in-place（原地算法）在数组上实现。具体算法描述如下：<br>1）从第一个元素开始，该元素可以认为已经被排序；<br>2）取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>3）如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>5）将新元素插入到该位置后；<br>6）重复步骤2~5。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#python实现</span><span class="token keyword">def</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> nums    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">#取出未排序部分的第一个元素</span>        preIndex <span class="token operator">=</span> i<span class="token number">-1</span>      <span class="token comment" spellcheck="true">#排序部分最后一位元素</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>preIndex<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> cur<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#跟前一位元素对比</span>            nums<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span>              preIndex<span class="token operator">-=</span><span class="token number">1</span>                            <span class="token comment" spellcheck="true">#从后往前比较</span>        nums<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> cur                     <span class="token comment" spellcheck="true">#插入元素</span>    <span class="token keyword">return</span> nums    </code></pre><pre><code>public static int[] insertionSort(int[] nums )&#123;    int n = nums.length;    if(n==0)&#123;return nums;&#125;    int cur;    for(int i=1;i&lt;n;i++)&#123;        cur = nums[i];        preIndex = i-1;        while(preIndex&gt;=0 &amp;&amp; cur&lt;nums[preIndex])&#123;            nums[preIndex+1]=nums[preIndex];            preIndex--;        &#125;        &#125;        nums[preIndex+1] = cur;&#125;</code></pre><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>直接插入排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。<br>最好情况：如果待排序元素本来是正序的，比较和移动元素的次数分别是 (n - 1) 和 0，因此最好情况的时间复杂度为O(n)。<br>最坏情况：如果待排序元素本来是逆序的，需要进行 (n - 1) 趟排序，所需比较和移动次数分别为 n * (n - 1) / 2和 n * (n - 1) / 2。因此最坏情况下的时间复杂度为O(n2)。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p>1）把长度为 n 的输入序列分成两个长度为 n / 2 的子序列；<br>2）对这两个子序列分别采用归并排序；<br>3）将两个排序好的子序列合并成一个最终的排序序列。</p><p>时间复杂度稳定为O(nlogn),空间复杂度O(n)，递归引用空间</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> nums    mid <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>        left <span class="token operator">=</span> mergeSort<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>    right <span class="token operator">=</span> mergeSort<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> merge<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""合并两个已拍好的列表，产生一个新的已排序好的列表"""</span>    result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    i <span class="token operator">=</span> <span class="token number">0</span>    j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">#队列表中的两个元素两两对比</span>    <span class="token comment" spellcheck="true">#将最小的元素，放到result中，并对当前下标+1</span>    <span class="token keyword">while</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        i<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        j<span class="token operator">+=</span><span class="token number">1</span>    result <span class="token operator">+=</span> left<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span>    result <span class="token operator">+=</span> right<span class="token punctuation">[</span>j<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> result</code></pre><pre><code>public static int[] mergeSort(int[] nums)&#123;    if(nums.length&lt;=1)&#123;    return nums;    &#125;    int mid = nums.length/2;    int[] left = Arrays.copyOfRange(nums,0,mid);    int[] right = Arrays.copyOfRange(nums,mid,nums.length);        return merge(mergeSort(left),mergeSort(right));&#125;public static int[] merge(int[] left, int[] right)&#123;    int[] result = new int[left.length + right.length];    int i=0,j=0,k=0;    while (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;            if (left[i] &lt;= right[j]) &#123;                result[k++] = left[i++];            &#125; else &#123;                result[k++] = right[j++];            &#125;        &#125;        while (i &lt; left.length) &#123;            result[k++] = left[i++];        &#125;        while (j &lt; right.length) &#123;            result[k++] = right[j++];        &#125;        return result;&#125;</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><p>快速排序使用分治法来把一个数列分为两个子数列。具体算法描述如下：<br>1）从数列中挑出一个元素，称为 “基准”（pivot）；<br>2）重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。这称为分区（partition）操作；<br>3）递归地（recursive）对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> nums    <span class="token keyword">else</span><span class="token punctuation">:</span>    cur <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    less <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">&lt;</span>cur<span class="token punctuation">]</span>    greater <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">>=</span>cur<span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>quicksort<span class="token punctuation">(</span>less<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">+</span>quicksort<span class="token punctuation">(</span>greater<span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><p>堆排序是一种树形选择排序方法，它利用了堆这种数据结构。在排序的过程中，将array[0，…，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大（最小）的元素。</p><p>② 概念<br>堆：堆是一种完全二叉树，且满足所有父节点的值均大于等于（或小于等于）其子节点的值。<br>大根堆（最大堆）：满足所有父节点的值均大于等于其子节点的值的堆称为大根堆，堆顶元素是堆中元素的最大值。<br>小根堆（最小堆）：满足所有父节点的值均小于等于其子节点的值的堆称为小根堆，堆顶元素是堆中元素的最小值。<br>堆的顺序存储结构：使用顺序数据结构（数组）存储堆，表示方法为：<br>1.数组按层序遍历的顺序存放完全二叉树的结点，下标为 0 处为堆顶，下标为 len - 1 处为堆尾。<br>2.结点 i 如果存在左孩子（下标不超过 len - 1 就存在），左孩子的下标为（2 * i + 1）；如果存在右孩子，右孩子的下标为（2 * i + 2）。结点 i 的父结点下标为 (i - 1) / 2 (下标为 0 的结点除外，它没有父结点)。最后一个非叶子结点即为堆尾元素的父结点，下标为 (len - 1 - 1) / 2 = (len - 2) / 2。</p><p>③ 算法描述<br>1）将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>2）将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>3）由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。</p><pre><code>//声明全局变量，用于记录数组array的长度；static int len;/** * 堆排序算法 * @param array * @return */public static int[] HeapSort(int[] array) &#123;        len = array.length;        if (len == 0) return array;        //1.构建一个大根堆        buildMaxHeap(array);        //2.循环将堆顶（最大值）与堆尾交换，删除堆尾元素，然后重新调整大根堆        while (len &gt; 0) &#123;            swap(array, 0, len - 1);            len--; //原先的堆尾进入有序区，删除堆尾元素            adjustHeap(array, 0); //重新调整大根堆        &#125;        return array; &#125; /**   * 自顶向下调整以 i 为根的堆为大根堆   * @param array   * @param i   */public static void adjustHeap(int[] array, int i) &#123;        int maxIndex = i;        //如果有左子树，且左子树大于父节点，则将最大指针指向左子树        if (2 * i + 1 &lt; len &amp;&amp; array[2 * i + 1] &gt; array[maxIndex])            maxIndex = 2 * i + 1;        //如果有右子树，且右子树大于父节点，则将最大指针指向右子树        if (2 * i + 2 &lt; len &amp;&amp; array[2 * i + 2] &gt; array[maxIndex])            maxIndex = 2 * i + 2;        //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。        if (maxIndex != i) &#123;            swap(array, maxIndex, i);            adjustHeap(array, maxIndex);        &#125; &#125; /**  * 自底向上构建初始大根堆  * @param array  */ public static void buildMaxHeap(int[] array) &#123;        //从最后一个非叶子节点开始自底向上构造大根堆        for (int i = (len - 2) / 2; i &gt;= 0; i--) &#123;             adjustHeap(array, i);        &#125; &#125;</code></pre><h2 id="二分查找（补充）"><a href="#二分查找（补充）" class="headerlink" title="二分查找（补充）"></a>二分查找（补充）</h2><pre><code>public statin int binarySearch(int[] arr, int target)&#123;    int low = 0;    int high = arr.length -1;    int mid = 0;    if(target&lt;arr[low] || target&gt;arr[high]||low&gt;high)&#123;return -1;&#125;        while(low&lt;=high)&#123;        mid = low+(high-low)/2; //避免int溢出        if(arr[mid]&gt;target)&#123;             high = mid-1;       //大于 -1    &#125;    if(arr[mid]&lt;target)&#123;     //小于+1        low = mid+1;    &#125;    else&#123;return mid;&#125;    &#125;    return -1;&#125;</code></pre><ul><li><a href="https://blog.csdn.net/bandaoyu/article/details/106596449?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&spm=1001.2101.3001.4242">算法详解二分查找算法（思路很简单，细节是魔鬼）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/image/java/sort.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相关资料：&lt;a href=&quot;https://www.jianshu.com/p/47170b1ced23&quot;&gt;https://www.jianshu.com/p/47170b1ced2</summary>
      
    
    
    
    <category term="算法" scheme="http://dennis174698.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://dennis174698.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java I/O</title>
    <link href="http://dennis174698.github.io/2021/05/24/Java-IO/"/>
    <id>http://dennis174698.github.io/2021/05/24/Java-IO/</id>
    <published>2021-05-24T07:13:53.000Z</published>
    <updated>2021-05-29T02:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-I-o"><a href="#Java-I-o" class="headerlink" title="Java I/o"></a>Java I/o</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Java 的I/O大概可以分成一下几类：</p><ol><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ol><p><img src="/image/java/io.png"><br>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p><p>InputStream 是抽象组件；</p><ul><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了文件字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。<br>InputStream的作用是用来表示那些从不同数据源产生输入的类。</li></ul><ol><li>字节数组</li><li>String对象</li><li>文件</li><li>“管道“，工作方式与实际管道类似，即一端输入另一端输出</li><li>其他数据源，如Internet连接等<br>Reader 与 Writer</li></ol><ul><li>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</li><li>InputStreamReader 实现从字节流解码成字符流；</li><li>OutputStreamWriter 实现字符流编码成为字节流。</li></ul><h2 id="常见的I-O模型对比"><a href="#常见的I-O模型对比" class="headerlink" title="常见的I/O模型对比"></a>常见的I/O模型对比</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a><strong>BIO</strong></h3><p>同步阻塞IO模型，当应用程序发起read之后，会一直阻塞，知道内核将数据准备就绪并把数据拷贝到用户空间，程序才会继续运行。<br><img src="/image/java/bio.png"></p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a><strong>NIO</strong></h3><p>NIO模式下，系统调用read，如果发现没数据已经到达，就会立刻返回-1。使用轮询的方式，不断的尝试有没有数据到达。没有得到数据就等一小会再试继续轮询。</p><p>NIO解决了线程阻塞的问题 ，但是会带来两个新问题：</p><ul><li>如果有IO连接都要检查，那么就得一个一个的read。这会带来大量的线程上下文切换（read是系统调用，每调用一次就得在用户态和核心态切换一次）</li><li>轮询的休息等待时间无法确定。这里是要猜多久之后数据才能到。等待时间设的太长，程序响应延迟就过大；设的太短，就会造成过于频繁的重试，干耗CPU而已。</li></ul><p><img src="/image/java/nio1.png"></p><h3 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a><strong>多路复用IO</strong></h3><p>多路复用使用select,poll,epoll函数实现，主要是将多个进程的IO注册到同一管道上统一管理。管道会统一和内核进行交互，告诉操作系统要监视这些IO是否有事件发生。<br><img src="/image/java/nio2.png"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。<br>特点及相关说明：</p><ul><li>IO多路复用是要和NIO一起使用的。尽管在操作系统级别，NIO和IO多路复用是两个相对独立的事情。也可以只用IO多路复用 + BIO，这时效果还是当前线程被卡住，没有达到IO多路复用的通知请求到来的效果。</li><li>IO多路复用说的是多个Socket或IO连接，只不过操作系统是一起监听他们的事件而已。</li></ul><p>多个数据流共享同一个TCP连接的场景的确是有，比如Http2 Multiplexing就是指Http2通讯中多个逻辑的数据流共享同一个TCP连接。但这与IO多路复用是完全不同的问题。</p><ul><li>IO多路复用的关键API调用(select，poll，epoll_wait）总是Block的</li><li>IO多路复用和NIO一起仅仅是解决了调度的问题，避免CPU在这个过程中的浪费，使系统的瓶颈更容易触达到网络带宽，而非CPU或者内存。要提高IO吞吐，还是提高硬件的容量（例如，用支持更大带宽的网线、网卡和交换机）和依靠并发传输（例如HDFS的数据多副本并发传输）。</li></ul><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a><strong>AIO</strong></h3><p>不会</p><h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h2><p>操作系统级别提供了一些接口来支持IO多路复用，最早的是select、poll，其后epoll是Linux下的IO多路复用的实现。</p><ul><li>select接口最早实现存在需要调用多次、线程不安全以及限制只能监视1024个链接的问题</li><li>poll接口修复了select函数的一些问题，但是依然不是线程安全的。</li><li>epoll接口修复了上述的问题，并且线程安全，会通知具体哪个连接有新数据。</li><li>epoll通过epoll_ctl()来注册一个文件描述符,一旦基于某个文件描述符就绪时,内核会采用类似callback的回调机制,迅速激活这个文件描述符,当进程调用epoll_wait()时便得到通知(不再需要遍历文件描述符,通过监听回调的机制,也是epoll的魅力)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-I-o&quot;&gt;&lt;a href=&quot;#Java-I-o&quot; class=&quot;headerlink&quot; title=&quot;Java I/o&quot;&gt;&lt;/a&gt;Java I/o&lt;/h1&gt;&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="http://dennis174698.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://dennis174698.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://dennis174698.github.io/2021/05/23/java/"/>
    <id>http://dennis174698.github.io/2021/05/23/java/</id>
    <published>2021-05-23T08:33:27.000Z</published>
    <updated>2021-05-26T23:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h2><h3 id="1-1-8种基本类型"><a href="#1-1-8种基本类型" class="headerlink" title="1.1 8种基本类型"></a>1.1 8种基本类型</h3><p><img src="/image/java/8.png"></p><h3 id="1-2-包装类型"><a href="#1-2-包装类型" class="headerlink" title="1.2 包装类型"></a>1.2 包装类型</h3><p>将简单类型包装为类,含有以下用途</p><ol><li>提供类的对象操作,如类型转换,进制转换等</li><li>集合不允许存放基本数据类型,使用包装类</li><li>包装类含有基本类型的相关属性,如最大值,最小值等</li></ol><p>包装类都为final不可继承</p><h3 id="1-3-装箱与拆箱"><a href="#1-3-装箱与拆箱" class="headerlink" title="1.3 装箱与拆箱"></a>1.3 装箱与拆箱</h3><p>Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)<br>int y = x;         // 拆箱 调用了 X.intValue()</p><p>new Integer(123) 和 Integer.valueOf(123) 区别<br>new Interger 新建了一个对象<br>.valueOf()会调用缓存池的对象,多次调用会取得同一对象的引用.</p><p>包装类型内存使用 private static class IntegerCache，声明一个内部使用的缓存池</p><p>如Integer中有个静态内部类IntegerCache，里面有个cache[],也就是Integer常量池，常量池的大小为一个字节（-128~127）<br>为啥把缓存设置为[-128，127]区间？性能和资源之间的权衡。 在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax= 来指定这个缓冲池的大小。<br>基本类型对应的缓冲池如下：</p><p>boolean values: true and false<br>all byte values<br>short values: between -128 and 127<br>int values: between -128 and 127<br>char: in the range \u0000 to \u007F</p><h3 id="1-4-String"><a href="#1-4-String" class="headerlink" title="1.4 String"></a>1.4 String</h3><p>String 被声明为final,不可继承,线程安全</p><ol><li><p>intern() 方法:<br>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；<br>否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p></li><li><p>运行效率<br>StringBuilder &gt; StringBuffer &gt; String<br>但是String str = “hello”+ “world”的效率就比 StringBuilder st = new StringBuilder().append(“hello”).append(“world”)要高</p></li><li><p>使用总结</p></li></ol><p><strong>少量数据:</strong> String<br><strong>单线程操作,字符缓冲区大量数据:</strong> Stringbuilder<br><strong>多线程操作,字符缓冲区大量数据:</strong> StringBuffer<br>4. 线程安全<br>String：对象定义后不可变，线程安全。<br>StringBuffer：是线程安全的（对调用方法加入同步锁），执行效率较慢，适用于多线程下操作字符串缓冲区大量数据。<br>StringBuilder：是线程不安全的，适用于单线程下操作字符串缓冲区大量数据。<br>5. 共同点<br>StringBuilder和StringBuffer有共同的父类AbstractStringBuilder（抽象类）。</p><p>　　StringBuilder和StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append（…）,只是StringBuffer会在方法上加上synchronized关键字进行同步。</p><pre><code>String a = &quot;hello2&quot;; 　  String b = &quot;hello&quot;;       String c = b + 2;       System.out.println((a == c));输出结果为:false。由于有符号引用的存在，所以  String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的String a = &quot;hello2&quot;;   　final String b = &quot;hello&quot;;       String c = b + 2;       System.out.println((a == c));输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问</code></pre><h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2.关键字"></a>2.关键字</h2><h3 id="2-1-final"><a href="#2-1-final" class="headerlink" title="2.1 final"></a>2.1 final</h3><ul><li><strong>数据</strong>:: 声明数据为常量,可以是编译时常量,也可以是在运行时被初始化后不能改变的常量</li><li><strong>基本类型:</strong>, 数据不变</li><li><strong>引用类型:</strong>, 是引用不变,但被引用的对象可以被改变</li><li>被修饰的数据在jvm常量池中</li><li>被修饰的类不能被继承,方法不能被重写</li></ul><h3 id="2-2-static"><a href="#2-2-static" class="headerlink" title="2.2 static"></a>2.2 static</h3><ul><li><strong>修饰类的话只能修饰内部类:</strong>, 非静态内部类编译完成之后会隐含一个引用,指向创建他的外围类,但是静态内部类没有. <strong>所以,静态内部类的创建不需要依赖外围类,不能使用任何外围类的非static成员变量和方法</strong></li><li><strong>修饰成员变量和成员方法:</strong>: 被类中所有的对象共享,存放在JVM方法区(1.8为Metaspace),类加载后可直接调用,aclass.staticMethod(),aclass.staticValue</li><li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li></ul><p>单例模式:</p><pre><code>class Singleton&#123;    private volatile static Singleton uniqueInstance;    private Sigleton()&#123;&#125;;    public static Singleton getSingleton()&#123;        if(uniqueInstance==null)&#123;        synchronized(Singleton.class)&#123;        if(uniqueInstance==null)&#123;            uniqueInstance = new Singleton();            &#125;                &#125;            &#125;    return uniqueInstance;        &#125;&#125;</code></pre><h3 id="2-3-super关键字"><a href="#2-3-super关键字" class="headerlink" title="2.3 super关键字"></a>2.3 super关键字</h3><p>用于子类从父类访问变量和方法</p><pre><code>class Animal&#123;    String color = &quot;white&quot;;&#125;class Dog extends Animal&#123;    String color = &quot;black&quot;;    void printColor()&#123;    System.out.println(color); //打印狗的color    System.out.println(super.color);//打印Animal 的color    &#125;&#125;</code></pre><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3.面向对象"></a>3.面向对象</h2><h3 id="3-1-三大特性"><a href="#3-1-三大特性" class="headerlink" title="3.1 三大特性"></a>3.1 三大特性</h3><ul><li><strong>封装:</strong> 指把对象的属性封装在对象内部,不允许外部对象直接访问对象的内部信息</li></ul><ol><li>把对象属性私有化,对每个属性提供getter,setter方法</li><li>如果有带参的构造函数,需要再写一个不带参的构造函数</li><li>建议重写toString方法</li><li>内部细节对外部调用透明,外部调用无需修改或者关心内部实现</li></ol><ul><li><strong>继承:</strong> 是使用已存在的类的定义作为基础建立新类的技术,新类的定义可以增加新的属性或新的方法,可以使用父类的功能,不能选择性继承.<br>通过继承,可以提高代码的复用率,提高开发效率.</li></ul><ol><li>子类拥有父类的属性和方法,但是私有方法和属性无法访问,只能拥有.</li><li>子类可以拥有自己的方法,在父类的基础上拓展.</li><li>可以用自己的方法实现父类的方法?</li></ol><ul><li><strong>多态:</strong> 指一个对象拥有多种状态. 具体表现为父类的引用指向子类的实例.</li></ul><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><pre><code>abstract class Animal&#123;    abstract void eat();&#125;class Cat extends Animal&#123;    public void eat()&#123; System.out.println(&quot;eat fish&quot;);&#125;&#125;class Dog extends Animal&#123;    public void eat()&#123;System.out.println(&quot;eat bones&quot;);&#125;&#125;class DuoTaiDemo&#123;    public static void main(String[] args)&#123;    function(new Cat());    function(new Dog());        Animal a = new Cat();    a.eat();    Cat c = (Cat)a;    c.eat();&#125;    public static void function(Animal a)&#123;    a.eat();    if(a instanceof Cat)&#123;Cat c = (Cat)a;c.catchMouse();&#125;    else if(a instanceof Dog)&#123;Dog c = (Dog)a;c.kanJia();&#125;    &#125;&#125;</code></pre><h3 id="3-2-重载和重写"><a href="#3-2-重载和重写" class="headerlink" title="3.2 重载和重写"></a>3.2 重载和重写</h3><p><strong>重载:</strong> 发生在同一个类中,方法名必须相同,参数类型不同,个数不同,顺序不同,方法返回值和访问修饰符可以不同.比如多个构造器.<br><strong>重写:</strong> 发生在运行期,子类对父类允许访问的方法进行重新编写.</p><ol><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><pre><code>public class Hero &#123;    public String name() &#123;        return &quot;超级英雄&quot;;    &#125;&#125;public class SuperMan extends Hero&#123;    @Override    public String name() &#123;        return &quot;超人&quot;;    &#125;    public Hero hero() &#123;        return new Hero();    &#125;&#125;public class SuperSuperMan extends SuperMan &#123;    public String name() &#123;        return &quot;超级超级英雄&quot;;    &#125;    @Override    public SuperMan hero() &#123;        return new SuperMan();    &#125;&#125;</code></pre><h3 id="3-3-泛型"><a href="#3-3-泛型" class="headerlink" title="3.3 泛型"></a>3.3 泛型</h3><p>泛型提供了编译时类型安全检测机制. 本质是参数化类型,也就是说操作的数据类型被指定为一个参数.<br>类型擦除: 在编译期间,所有的泛型信息都会被擦掉.</p><ul><li>泛型方法</li></ul><pre><code>public static &lt;E&gt; void printArray(E() inputArray)&#123;    for(E element: inputArray)&#123;    System.out.println(&quot;%s&quot;,element);    &#125;&#125; //传入不同类型数组: Interger,Double 和 Charcter // 打印不同数组</code></pre><ul><li>泛型类</li></ul><pre><code>public class Generic&lt;T&gt;&#123;    private T key;    public Generic(T key)&#123;    this.key = key;    &#125;    public T getKey()&#123;return key;&#125;&#125;Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</code></pre><ul><li>泛型接口</li></ul><pre><code>public interface Generic&lt;T&gt;&#123; public T method();&#125;//实现泛型接口，不指定类型：class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;&#123;    @Override    public T method() &#123;        return null;    &#125;&#125;Copy to clipboardErrorCopied//实现泛型接口，指定类型：class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;&#123;    @Override    public String method() &#123;        return &quot;hello&quot;;    &#125;&#125;</code></pre><p>常用的通配符为： T，E，K，V，？</p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h3 id="3-4-接口和抽象类"><a href="#3-4-接口和抽象类" class="headerlink" title="3.4 接口和抽象类"></a>3.4 接口和抽象类</h3><ul><li>接口<ul><li>接口是抽象类的延伸</li><li>从Java8开始,可以拥有默认的方法实现</li><li>接口的字段+方法默认都是public的,且不允许定义为private或protected</li><li>接口的字段默认都是static 和 final的</li></ul></li></ul><pre><code>public class Main &#123;    public static void main(String[] args) &#123;        Person p = new Student(&quot;Xiao Ming&quot;);        p.run();    &#125;&#125;interface Person &#123;    String getName();    default void run() &#123;        System.out.println(getName() + &quot; run&quot;);    &#125;&#125;class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return this.name;    &#125;&#125;//Xiao ming run</code></pre><ul><li>抽象类<ul><li>如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</li><li>抽象类和抽象方法都使用 abstract 关键字进行声明</li></ul></li></ul><p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p><p><strong>比较</strong></p><ul><li>抽象类的目的是实现代码复用,一种模板设计的方法,可以让这些类都派生于一个抽象类。</li><li>接口的设计目的是对类的行为进行约束,提供一种机制,使不同的类可以继承相同的功能。</li><li>接口的字段只能是static 和final,抽象类的字段没有这些要求。</li><li>接口的成员只能是public,抽象类可以有不同的访问权限。</li></ul><h3 id="3-5-反射"><a href="#3-5-反射" class="headerlink" title="3.5 反射"></a>3.5 反射</h3><ul><li>JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息。</li><li>通过Class实例获取 class信息的方法成为反射。</li></ul><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><ul><li>当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</li><li>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。</li><li>也可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</li></ul><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。</li></ul><pre><code>通过反射创建对象Class clazz = Class.forName(&quot;reflection.Person&quot;);//获取 Person 类的 Class 对象Person p = (Person)class.newInstance();//使用.newInstane 方法创建对象Constructor c = class.getDeclaredConstructor(String.class,String.class,int.class);//获取构造方法并创建对象Person p1 = (Person)c.newInstance(&quot;李四&quot;,&quot;男&quot;,&quot;20&quot;);//创建对象并设置属性</code></pre><h2 id="4-Java8新特性"><a href="#4-Java8新特性" class="headerlink" title="4.Java8新特性"></a>4.Java8新特性</h2><h3 id="4-1-streams（流）"><a href="#4-1-streams（流）" class="headerlink" title="4.1 streams（流）"></a>4.1 streams（流）</h3><ul><li><strong>Fliter</strong></li></ul><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p><pre><code>stringList    .stream()    .filter((s)-&gt;s.startsWith(&quot;a&quot;))    .forEach(System.out::println);</code></pre><ul><li><strong>Sorted</strong></li></ul><pre><code>stringList    .stream()    .sorted()    .filter((s)-&gt;s.startsWith(&quot;a&quot;))    .forEach(System.out::println);</code></pre><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：</p><ul><li><strong>Map</strong></li></ul><p>中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。<br>下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p><pre><code>stringList    .stream()    .map(String::toUpperCase)    .sorted((a,b)-&gt;b.compareTo(a))    .forEach(System.out::println);</code></pre><ul><li><strong>Match</strong></li></ul><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 最终操作 ，并返回一个 boolean 类型的值。</p><pre><code>// 测试 Match (匹配)操作        boolean anyStartsWithA =                stringList                        .stream()                        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));        System.out.println(anyStartsWithA);      // true        boolean allStartsWithA =                stringList                        .stream()                        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));        System.out.println(allStartsWithA);      // false        boolean noneStartsWithZ =                stringList                        .stream()                        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));        System.out.println(noneStartsWithZ);      // true</code></pre><ul><li><strong>Count</strong></li></ul><p>计数是一个 最终操作，返回Stream中元素的个数，返回值类型是 long。</p><pre><code>//测试 Count (计数)操作long startsWithB =stringList          .stream()          .filter((s) -&gt; s.startsWith(&quot;b&quot;))          .count();System.out.println(startsWithB);    // 3</code></pre><ul><li>Reduce(规约)</li></ul><p>这是一个 最终操作 ，允许通过指定的函数来将stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：</p><pre><code>//测试 Reduce (规约)操作        Optional&lt;String&gt; reduced =                stringList                        .stream()                        .sorted()                        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);        reduced.ifPresent(System.out::println);//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2</code></pre><p>译者注： 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于Integer sum = integers.reduce(0, (a, b) -&gt; a+b);也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><pre><code>// 字符串连接，concat = &quot;ABCD&quot;String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); // 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = &quot;ace&quot;concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;). filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0). reduce(&quot;&quot;, String::concat);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; class=&quot;headerlink&quot; title=&quot;Java基础&quot;&gt;&lt;/a&gt;Java基础&lt;/h1&gt;&lt;h2 id=&quot;1-基本数据类型&quot;&gt;&lt;a href=&quot;#1-基本数据类型&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="java" scheme="http://dennis174698.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://dennis174698.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>二叉树专项练习（三）（depth&amp;height）</title>
    <link href="http://dennis174698.github.io/2021/03/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%88depth-height%EF%BC%89/"/>
    <id>http://dennis174698.github.io/2021/03/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%88depth-height%EF%BC%89/</id>
    <published>2021-03-15T14:46:02.000Z</published>
    <updated>2021-03-20T21:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a><br>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>输出：true</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> abs<span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a><br>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>输出：<span class="token number">2</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token comment" spellcheck="true"># class Solution:</span><span class="token comment" spellcheck="true">#     def minDepth(self, root: TreeNode) -> int:</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        que <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> que<span class="token punctuation">:</span>            node<span class="token punctuation">,</span> depth <span class="token operator">=</span> que<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> node<span class="token punctuation">.</span>left <span class="token operator">and</span> <span class="token operator">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> depth            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                que<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                que<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token number">0</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a><br>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">给定二叉树 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>，    <span class="token number">3</span>   <span class="token operator">/</span> \  <span class="token number">9</span>  <span class="token number">20</span>    <span class="token operator">/</span>  \   <span class="token number">15</span>   <span class="token number">7</span>返回它的最大深度 <span class="token number">3</span> 。</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left <span class="token operator">and</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        max_depth <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>            max_depth <span class="token operator">=</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> max_depth<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            max_depth <span class="token operator">=</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> max_depth<span class="token punctuation">)</span>                <span class="token keyword">return</span> max_depth <span class="token operator">+</span> <span class="token number">1</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a><br>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。<br>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>输出：<span class="token number">6</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">return</span> left<span class="token operator">+</span>right<span class="token operator">+</span><span class="token number">1</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a><br>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>解释<span class="token punctuation">:</span>   <span class="token number">1</span>            <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">/</span>   \<span class="token number">2</span>     <span class="token number">3</span>         <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> \     \  <span class="token number">5</span>     <span class="token number">4</span>       <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>                rightmost_value_at_depth <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 深度为索引，存放节点的值</span>        max_depth <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            node<span class="token punctuation">,</span> depth <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 维护二叉树的最大深度</span>                max_depth <span class="token operator">=</span> max<span class="token punctuation">(</span>max_depth<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 如果不存在对应深度的节点我们才插入</span>                rightmost_value_at_depth<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>depth<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>rightmost_value_at_depth<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token keyword">for</span> depth <span class="token keyword">in</span> range<span class="token punctuation">(</span>max_depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/balanced-binary-tree/&quot;&gt;110. 平衡二叉树&lt;/a&gt;&lt;br&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;br&gt;本题中，一棵高度平衡二叉树定义为：&lt;br&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/categories/leetcode/"/>
    
    <category term="二叉树" scheme="http://dennis174698.github.io/categories/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://dennis174698.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树专项练习（二）（构建树）</title>
    <link href="http://dennis174698.github.io/2021/03/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%88%E6%9E%84%E5%BB%BA%E6%A0%91%EF%BC%89/"/>
    <id>http://dennis174698.github.io/2021/03/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%88%E6%9E%84%E5%BB%BA%E6%A0%91%EF%BC%89/</id>
    <published>2021-03-09T13:31:35.000Z</published>
    <updated>2021-03-20T21:40:28.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008. 前序遍历构造二叉搜索树</a><br>返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。</li></ul><p>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）</p><p>题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bstFromPreorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>lower <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> upper <span class="token operator">=</span> float…            <span class="token keyword">return</span> root                idx <span class="token operator">=</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span>        <span class="token keyword">return</span> helper<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a><br>根据一棵树的前序遍历与中序遍历构造二叉树。</li></ul><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder</p><pre class=" language-python"><code class="language-python">前序遍历 preorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>中序遍历 inorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>返回如下的二叉树：    <span class="token number">3</span>   <span class="token operator">/</span> \  <span class="token number">9</span>  <span class="token number">20</span>    <span class="token operator">/</span>  \   <span class="token number">15</span>   <span class="token number">7</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> preorder <span class="token operator">or</span> <span class="token operator">not</span> inorder<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#根节点为前序遍历第一个节点</span>        index <span class="token operator">=</span> inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 定位出中序遍历根节点的索引</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># 递归构建左子树，前序遍历左子树范围为，1~index,中序遍历左子树范围为0~index-1</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 递归构建右子树，前序遍历右子树范围为index之后，中序遍历右子树范围为index往后</span>        <span class="token keyword">return</span> root</code></pre><ul><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a><br>根据一棵树的中序遍历与后序遍历构造二叉树。</li></ul><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><pre class=" language-python"><code class="language-python">中序遍历 inorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>后序遍历 postorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>返回如下的二叉树：    <span class="token number">3</span>   <span class="token operator">/</span> \  <span class="token number">9</span>  <span class="token number">20</span>    <span class="token operator">/</span>  \   <span class="token number">15</span>   <span class="token number">7</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> inorder <span class="token operator">or</span> <span class="token operator">not</span> postorder<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        index <span class="token operator">=</span> inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>postorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>postorder<span class="token punctuation">[</span>index<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root</code></pre><ul><li><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a><br>返回与给定的前序和后序遍历匹配的任何二叉树。</p><p>pre 和 post 遍历中的值是不同的正整数。</p></li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：pre <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> post <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token number">1</span> <span class="token operator">&lt;=</span> pre<span class="token punctuation">.</span>length <span class="token operator">==</span> post<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">30</span>pre<span class="token punctuation">[</span><span class="token punctuation">]</span> 和 post<span class="token punctuation">[</span><span class="token punctuation">]</span> 都是 <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> pre<span class="token punctuation">.</span>length 的排列每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">constructFromPrePost</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pre<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> post<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> pre <span class="token operator">or</span> <span class="token operator">not</span> post<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>pre<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> root        index <span class="token operator">=</span> post<span class="token punctuation">.</span>index<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 后序遍历右子树起始位置</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>constructFromPrePost<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>post<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>constructFromPrePost<span class="token punctuation">(</span>pre<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>post<span class="token punctuation">[</span>index<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root</code></pre><ul><li><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a><br>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</li></ul><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>解释：<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span> 也将被视为正确答案：</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span>         mid <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">//</span><span class="token number">2</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>        left <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span>        right <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>sortedArrayToBST<span class="token punctuation">(</span>left<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>sortedArrayToBST<span class="token punctuation">(</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/&quot;&gt;1008. 前序遍历构造二叉搜索树&lt;/a&gt;&lt;br&gt;返回与给定前序遍历</summary>
      
    
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/categories/leetcode/"/>
    
    <category term="二叉数" scheme="http://dennis174698.github.io/categories/leetcode/%E4%BA%8C%E5%8F%89%E6%95%B0/"/>
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://dennis174698.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树专项练习（一）（遍历思想）</title>
    <link href="http://dennis174698.github.io/2021/03/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://dennis174698.github.io/2021/03/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-03-05T13:18:10.000Z</published>
    <updated>2021-03-20T21:28:40.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a><br>给定一个 N 叉树，返回其节点值的 前序遍历 。</li></ul><p>N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p><p>进阶：</p><p>递归法很简单，你可以使用迭代法完成此题吗?<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, val=None, children=None):        self.val = val        self.children = children"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>                    helper<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a><br>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a><br>给定一个二叉树，返回它的 后序 遍历。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>     <span class="token number">1</span>    \     <span class="token number">2</span>    <span class="token operator">/</span>   <span class="token number">3</span> 输出<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><p>+<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a><br>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">二叉树：<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">3</span>   <span class="token operator">/</span> \  <span class="token number">9</span>  <span class="token number">20</span>    <span class="token operator">/</span>  \   <span class="token number">15</span>   <span class="token number">7</span>返回其层序遍历结果：<span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>…        helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a><br>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</li></ul><pre class=" language-python"><code class="language-python">例如：给定二叉树 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">3</span>   <span class="token operator">/</span> \  <span class="token number">9</span>  <span class="token number">20</span>    <span class="token operator">/</span>  \   <span class="token number">15</span>   <span class="token number">7</span>返回其自底向上的层序遍历为：<span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrderBottom</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>…        helper<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/&quot;&gt;589. N 叉树的前序遍历&lt;/a&gt;&lt;br&gt;给定一个 N 叉树，返回其节点值的 前序遍历 。&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/categories/leetcode/"/>
    
    <category term="二叉树" scheme="http://dennis174698.github.io/categories/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/tags/leetcode/"/>
    
    <category term="二叉树" scheme="http://dennis174698.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>链表专项练习（二）</title>
    <link href="http://dennis174698.github.io/2021/02/21/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://dennis174698.github.io/2021/02/21/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-21T13:00:23.000Z</published>
    <updated>2021-03-20T21:15:18.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>[83.删除排序链表中的重复元素] (<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a>)<br>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span>输出<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        sen <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        sen<span class="token punctuation">.</span>next <span class="token operator">=</span> head        pre<span class="token punctuation">,</span>cur <span class="token operator">=</span> sen<span class="token punctuation">,</span>head        rep <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>val <span class="token keyword">in</span> rep<span class="token punctuation">:</span>                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                rep<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> sen<span class="token punctuation">.</span>next</code></pre><ul><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82.删除排序链表中的重复元素</a><br>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span>输出<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token operator">==</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head        slow <span class="token operator">=</span> dummy        fast <span class="token operator">=</span> dummy<span class="token punctuation">.</span>next        <span class="token keyword">while</span> fast<span class="token punctuation">:</span>            <span class="token keyword">while</span> fast<span class="token punctuation">.</span>next <span class="token operator">and</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next            <span class="token keyword">if</span> slow<span class="token punctuation">.</span>next <span class="token operator">==</span> fast<span class="token punctuation">:</span>                slow <span class="token operator">=</span> fast            <span class="token keyword">else</span><span class="token punctuation">:</span>                slow<span class="token punctuation">.</span>next <span class="token operator">=</span> fast<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next</code></pre><ul><li><a href="https://www.realestate.com.au/property-house-vic-melbourne-129654678">21.合并两个有序链表</a></li></ul><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：l1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> l1<span class="token punctuation">:</span>            <span class="token keyword">return</span> l2        <span class="token keyword">elif</span> <span class="token operator">not</span> l2<span class="token punctuation">:</span>            <span class="token keyword">return</span> l1        <span class="token keyword">if</span> l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            l1<span class="token punctuation">.</span>next <span class="token operator">=</span>  self<span class="token punctuation">.</span>mergeTwoLists<span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span>l2<span class="token punctuation">)</span>            <span class="token keyword">return</span> l1        <span class="token keyword">elif</span> l1<span class="token punctuation">.</span>val<span class="token operator">>=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            l2<span class="token punctuation">.</span>next <span class="token operator">=</span>  self<span class="token punctuation">.</span>mergeTwoLists<span class="token punctuation">(</span>l2<span class="token punctuation">.</span>next<span class="token punctuation">,</span>l1<span class="token punctuation">)</span>            <span class="token keyword">return</span> l2</code></pre><ul><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141.环形链表</a><br>给定一个链表，判断链表中是否有环。</li></ul><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">1</span>输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head <span class="token operator">or</span> <span class="token operator">not</span> head<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next        slow <span class="token operator">=</span> head        <span class="token keyword">while</span> slow<span class="token operator">!=</span>fast<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> fast <span class="token operator">or</span> <span class="token operator">not</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">True</span></code></pre><p>+<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142.环形链表 II</a><br>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O(1) 空间解决此题？</p><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">1</span>输出：返回索引为 <span class="token number">1</span> 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        fast<span class="token punctuation">,</span>slow <span class="token operator">=</span> head<span class="token punctuation">,</span>head        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>…            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;[83.删除排序链表中的重复元素] (&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/&quot;&gt;https://leetcode-cn.com/problems/</summary>
      
    
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/categories/leetcode/"/>
    
    <category term="链表" scheme="http://dennis174698.github.io/categories/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/tags/leetcode/"/>
    
    <category term="链表" scheme="http://dennis174698.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表专项练习（一）</title>
    <link href="http://dennis174698.github.io/2021/02/11/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://dennis174698.github.io/2021/02/11/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-10T17:09:59.000Z</published>
    <updated>2021-03-10T01:28:06.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206.反转链表</a><br>反转一个单链表。</li></ul><p><strong>示例:</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>NULL输出<span class="token punctuation">:</span> <span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span>NULL</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span>            <span class="token keyword">return</span>        pre <span class="token operator">=</span> None        cur <span class="token operator">=</span> head                <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre            pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> tmp        <span class="token keyword">return</span> pre</code></pre><p>+<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92.反转链表 II</a><br>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。<br><strong>示例:</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>NULL<span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">4</span>输出<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>NULL</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> left<span class="token punctuation">:</span> int<span class="token punctuation">,</span> right<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummy_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy_node<span class="token punctuation">.</span>next <span class="token operator">=</span> head        pre <span class="token operator">=</span> dummy_node        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next        cur <span class="token operator">=</span> pre<span class="token punctuation">.</span>next        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">:</span>            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next            next<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> next        <span class="token keyword">return</span> dummy_node<span class="token punctuation">.</span>next</code></pre><ul><li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328.奇偶链表</a><br>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</li></ul><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br><strong>示例:</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>NULL输出<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span>NULL</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span>            <span class="token keyword">return</span>        even<span class="token punctuation">,</span>odd <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head        evenhead <span class="token operator">=</span> head<span class="token punctuation">.</span>next        <span class="token keyword">while</span> even <span class="token operator">and</span> even<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            odd<span class="token punctuation">.</span>next <span class="token operator">=</span> even<span class="token punctuation">.</span>next            odd <span class="token operator">=</span> odd<span class="token punctuation">.</span>next            even<span class="token punctuation">.</span>next <span class="token operator">=</span> odd<span class="token punctuation">.</span>next            even <span class="token operator">=</span> even<span class="token punctuation">.</span>next        odd<span class="token punctuation">.</span>next <span class="token operator">=</span> evenhead        <span class="token keyword">return</span> head</code></pre><p>+[86.分隔链表] (<a href="https://leetcode-cn.com/problems/partition-list/">https://leetcode-cn.com/problems/partition-list/</a>)<br>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><p><strong>示例:</strong></p><pre class=" language-python"><code class="language-python">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token number">3</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span>            <span class="token keyword">return</span>        large <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        small <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cur <span class="token operator">=</span> head        largeCur <span class="token operator">=</span> large        smallCur <span class="token operator">=</span> small        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>val <span class="token operator">>=</span> x<span class="token punctuation">:</span>                largeCur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next                largeCur <span class="token operator">=</span> largeCur<span class="token punctuation">.</span>next                largeCur<span class="token punctuation">.</span>next <span class="token operator">=</span> None            <span class="token keyword">else</span><span class="token punctuation">:</span>                smallCur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next                smallCur <span class="token operator">=</span> smallCur<span class="token punctuation">.</span>next                smallCur<span class="token punctuation">.</span>next <span class="token operator">=</span> None        smallCur<span class="token punctuation">.</span>next <span class="token operator">=</span> large<span class="token punctuation">.</span>next        <span class="token keyword">return</span> small<span class="token punctuation">.</span>next</code></pre><p>+<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203.移除链表元素</a><br>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。<br><strong>示例</strong>:</p><pre class=" language-python"><code class="language-python">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> val <span class="token operator">=</span> <span class="token number">6</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        sen <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        sen<span class="token punctuation">.</span>next <span class="token operator">=</span> head        pre<span class="token punctuation">,</span>cur <span class="token operator">=</span> sen<span class="token punctuation">,</span>head        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">:</span>                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> sen<span class="token punctuation">.</span>next</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot;&gt;206.反转链表&lt;/a&gt;&lt;br&gt;反转一个单链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pr</summary>
      
    
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/categories/leetcode/"/>
    
    <category term="链表" scheme="http://dennis174698.github.io/categories/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/tags/leetcode/"/>
    
    <category term="链表" scheme="http://dennis174698.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>动态规划专项练习（二）</title>
    <link href="http://dennis174698.github.io/2021/02/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://dennis174698.github.io/2021/02/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-06T15:56:34.000Z</published>
    <updated>2021-03-06T00:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>打开题目-&gt;思索半天-&gt;打开题解-&gt;思索一会-&gt;妙不可言-&gt;我是废物</strong><br>+<a href="https://leetcode-cn.com/problems/house-robber/">198.打家劫舍</a><br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>输出：<span class="token number">4</span>解释：偷窃 <span class="token number">1</span> 号房屋 <span class="token punctuation">(</span>金额 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> ，然后偷窃 <span class="token number">3</span> 号房屋 <span class="token punctuation">(</span>金额 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>。     偷窃到的最高金额 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">4</span> 。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>n<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>+<a href="https://leetcode-cn.com/problems/house-robber-ii/">213.打家劫舍②</a><br>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>输出：<span class="token number">3</span>解释：你不能先偷窃 <span class="token number">1</span> 号房屋（金额 <span class="token operator">=</span> <span class="token number">2</span>），然后偷窃 <span class="token number">3</span> 号房屋（金额 <span class="token operator">=</span> <span class="token number">2</span>）<span class="token punctuation">,</span> 因为他们是相邻的。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token operator">==</span>None <span class="token operator">or</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        dp1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dp2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dp1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        dp1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        dp2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        dp2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            dp2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp2<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp2<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>+<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416.分割等和子集</a><br>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><p>每个数组中的元素不会超过 100<br>数组的大小不会超过 200<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> true解释<span class="token punctuation">:</span> 数组可以分割成 <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span> 和 <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">.</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        target <span class="token operator">=</span> sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">if</span> sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        maxnum <span class="token operator">=</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> maxnum <span class="token operator">></span> target<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j <span class="token operator">>=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span></code></pre><p>+<a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474.一和零</a><br>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：strs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"10"</span><span class="token punctuation">,</span> <span class="token string">"0001"</span><span class="token punctuation">,</span> <span class="token string">"111001"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">3</span>输出：<span class="token number">4</span>解释：最多有 <span class="token number">5</span> 个 <span class="token number">0</span> 和 <span class="token number">3</span> 个 <span class="token number">1</span> 的最大子集是 <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"10","0001","1","0"&amp;#125; ，因此答案是 4 。</span>其他满足题意但较小的子集包括 <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"0001","1"&amp;#125; 和 &amp;#123;"10","1","0"&amp;#125; 。&amp;#123;"111001"&amp;#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span></code></pre><pre class=" language-python"><code class="language-python">        <span class="token keyword">if</span> len<span class="token punctuation">(</span>strs<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> strs_item <span class="token keyword">in</span> strs<span class="token punctuation">:</span>            zeros <span class="token operator">=</span> strs_item<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span>            ones <span class="token operator">=</span> strs_item<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">,</span> zeros <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">,</span> ones <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span> zeros<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>ones<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">978.最长湍流子数组</a><br>当 A 的子数组 A[i], A[i+1], …, A[j] 满足下列条件时，我们称其为湍流子数组：</li></ul><p>若 i &lt;= k &lt; j，当 k 为奇数时， A[k] &gt; A[k+1]，且当 k 为偶数时，A[k] &lt; A[k+1]；<br>或 若 i &lt;= k &lt; j，当 k 为偶数时，A[k] &gt; A[k+1] ，且当 k 为奇数时， A[k] &lt; A[k+1]。<br>也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。</p><p>返回 A 的最大湍流子数组的长度。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>输出：<span class="token number">5</span>解释：<span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> A<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> A<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxTurbulenceSize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        up <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>n        down <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>n        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                down<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> up<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> arr<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> down<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span>max<span class="token punctuation">(</span>down<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><p>+<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96.不同的二叉搜索数</a><br>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">3</span>输出<span class="token punctuation">:</span> <span class="token number">5</span>解释<span class="token punctuation">:</span>给定 n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> 一共有 <span class="token number">5</span> 种不同结构的二叉搜索树<span class="token punctuation">:</span>   <span class="token number">1</span>         <span class="token number">3</span>     <span class="token number">3</span>      <span class="token number">2</span>      <span class="token number">1</span>    \       <span class="token operator">/</span>     <span class="token operator">/</span>      <span class="token operator">/</span> \      \     <span class="token number">3</span>     <span class="token number">2</span>     <span class="token number">1</span>      <span class="token number">1</span>   <span class="token number">3</span>      <span class="token number">2</span>    <span class="token operator">/</span>     <span class="token operator">/</span>       \                 \   <span class="token number">2</span>     <span class="token number">1</span>         <span class="token number">2</span>                 <span class="token number">3</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># g(n) = f(1)+f(2)+...+f(n)</span>        <span class="token comment" spellcheck="true"># f(i) = g(i-1)*g(n-i) </span>        <span class="token comment" spellcheck="true"># f(5) = g(5-1)*g(5-5)</span>        <span class="token comment" spellcheck="true">#      = g(4)*g(0)</span>        <span class="token comment" spellcheck="true">#      = </span>        <span class="token comment" spellcheck="true"># g(n) = g(n-1)*g(0) + g(n-2)*g(1)+...g(n-i)*g(i-1)</span>        g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>g<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>             g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> g<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token operator">*</span>g<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> g<span class="token punctuation">[</span>n<span class="token punctuation">]</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;打开题目-&amp;gt;思索半天-&amp;gt;打开题解-&amp;gt;思索一会-&amp;gt;妙不可言-&amp;gt;我是废物&lt;/strong&gt;&lt;br&gt;+&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/&quot;&gt;198.打家劫舍&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/tags/leetcode/"/>
    
    <category term="动态规划" scheme="http://dennis174698.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划专项练习（一）</title>
    <link href="http://dennis174698.github.io/2021/02/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://dennis174698.github.io/2021/02/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-02T13:03:24.000Z</published>
    <updated>2021-02-27T21:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>下面是「动态规划』问题的思考路径，供大家参考。<br><img src="/image/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png"></p><p>转载自：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p><ul><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5.最长回文子串</a><br>给你一个字符串 s，找到 s 中最长的回文子串。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：s <span class="token operator">=</span> <span class="token string">"babad"</span>输出：<span class="token string">"bab"</span>解释：<span class="token string">"aba"</span> 同样是符合题意的答案。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token operator">*</span>n <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        ans <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">for</span> l <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> i<span class="token operator">+</span>l                <span class="token keyword">if</span> j<span class="token operator">>=</span>n<span class="token punctuation">:</span>                    <span class="token keyword">break</span>                <span class="token keyword">if</span> l <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                <span class="token keyword">elif</span> l <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">and</span> l<span class="token operator">+</span><span class="token number">1</span><span class="token operator">></span>len<span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">:</span>                    ans <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">:</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> ans</code></pre><ul><li><a href="https://leetcode-cn.com/problems/maximum-subarray/">53.最大子序和</a><br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出：<span class="token number">6</span>解释：连续子数组 <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> 的和最大，为 <span class="token number">6</span> 。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        cur <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                        cur <span class="token operator">=</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>cur<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span>cur<span class="token punctuation">)</span>                    <span class="token keyword">return</span> res</code></pre><ul><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152.乘机最大子数组</a><br>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> <span class="token number">6</span>解释<span class="token punctuation">:</span> 子数组 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> 有最大乘积 <span class="token number">6</span>。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span>         res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        pre_max <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        pre_min <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            cur_max <span class="token operator">=</span> max<span class="token punctuation">(</span>pre_max <span class="token operator">*</span> num<span class="token punctuation">,</span> pre_min <span class="token operator">*</span> num<span class="token punctuation">,</span> num<span class="token punctuation">)</span>            cur_min <span class="token operator">=</span> min<span class="token punctuation">(</span>pre_max <span class="token operator">*</span> num<span class="token punctuation">,</span> pre_min <span class="token operator">*</span> num<span class="token punctuation">,</span> num<span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> cur_max<span class="token punctuation">)</span>            pre_max <span class="token operator">=</span> cur_max            pre_min <span class="token operator">=</span> cur_min        <span class="token keyword">return</span> res</code></pre><ul><li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300.最长递增子序列</a><br>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">]</span>输出：<span class="token number">4</span>解释：最长递增子序列是 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">101</span><span class="token punctuation">]</span>，因此长度为 <span class="token number">4</span> 。</code></pre><pre class=" language-python"><code class="language-python">       <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143.最长公共子序列</a><br>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</li></ul><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：text1 <span class="token operator">=</span> <span class="token string">"abcde"</span><span class="token punctuation">,</span> text2 <span class="token operator">=</span> <span class="token string">"ace"</span> 输出：<span class="token number">3</span>  解释：最长公共子序列是 <span class="token string">"ace"</span>，它的长度为 <span class="token number">3</span>。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> text2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span>m <span class="token operator">=</span> len<span class="token punctuation">(</span>text1<span class="token punctuation">)</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>text2<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> text1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;p&gt;下面是「动态规划』问题的思考路径，供大家参考。&lt;br&gt;&lt;img src=&quot;/image/%E5%8A%A8%E6%80%81</summary>
      
    
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/tags/leetcode/"/>
    
    <category term="动态规划" scheme="http://dennis174698.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode股票问题DP解法</title>
    <link href="http://dennis174698.github.io/2021/02/01/leetcode%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98DP%E8%A7%A3%E6%B3%95/"/>
    <id>http://dennis174698.github.io/2021/02/01/leetcode%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98DP%E8%A7%A3%E6%B3%95/</id>
    <published>2021-02-01T03:05:00.000Z</published>
    <updated>2021-02-27T13:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>力扣的股票问题一共有6道：</p><ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></li></ul><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>动态规划并不是这些问题的唯一解也不是最优解，但是相比于dp，其他解法并未建立起问题之间的联系，有些解法则难以理解。下面根据题目的难度以及条件的复杂度顺序给出dp题解，层层跟进，易于理解。</p><p><strong>+ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></strong><br>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出：<span class="token number">5</span>解释：在第 <span class="token number">2</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">1</span>）的时候买入，在第 <span class="token number">5</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">6</span>）的时候卖出，最大利润 <span class="token operator">=</span> <span class="token number">6</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">5</span> 。     注意利润不能是 <span class="token number">7</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>           <span class="token comment" spellcheck="true"># 构建2维的dp数组</span>        <span class="token comment" spellcheck="true"># dp[i][0] 为第i天不持股的利润</span>        <span class="token comment" spellcheck="true"># dp[i][1] 为第i天持股的利润</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 特殊情况，在第一天购入股票的利润</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">#第i天不持股的利润为前一天不持股状态的利润和昨天持股今天卖出的利润之间的最大值</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#第i天持股的利润为前一天持股状态的利润和今天买入的利润之间的最大值</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><p><strong>+ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></strong></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> <span class="token number">7</span>解释<span class="token punctuation">:</span> 在第 <span class="token number">2</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">1</span>）的时候买入，在第 <span class="token number">3</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">5</span>）的时候卖出<span class="token punctuation">,</span> 这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">5</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">4</span> 。     随后，在第 <span class="token number">4</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">3</span>）的时候买入，在第 <span class="token number">5</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">6</span>）的时候卖出<span class="token punctuation">,</span> 这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">6</span><span class="token operator">-</span><span class="token number">3</span> <span class="token operator">=</span> <span class="token number">3</span> 。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> prices<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                 <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#第i天不持股的利润为前一天不持股状态的利润和昨天持股今天卖出的利润之间的最大值</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">#第i天持股的利润为前一天持股状态的利润和昨天不持股今天买入的利润之间的最大值</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><strong>+ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></strong><br>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> prices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fee <span class="token operator">=</span> <span class="token number">2</span>输出<span class="token punctuation">:</span> <span class="token number">8</span>解释<span class="token punctuation">:</span> 能够达到的最大利润<span class="token punctuation">:</span>  在此处买入 prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>在此处卖出 prices<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">8</span>在此处买入 prices<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>在此处卖出 prices<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span>总利润<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">9</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">.</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span>fee<span class="token punctuation">:</span>int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> prices<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>fee        <span class="token comment" spellcheck="true">#相比与上一题在买入时多增加了一个手续费而已</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#第i天不持股的利润为前一天不持股状态的利润和昨天持股今天卖出的利润之间的最大值</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>fee<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">#第i天持股的利润为前一天持股状态的利润和昨天不持股今天买入的利润之间的最大值</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><p><strong>+ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></strong><br>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> <span class="token number">3</span> 解释<span class="token punctuation">:</span> 对应的交易状态为<span class="token punctuation">:</span> <span class="token punctuation">[</span>买入<span class="token punctuation">,</span> 卖出<span class="token punctuation">,</span> 冷冻期<span class="token punctuation">,</span> 买入<span class="token punctuation">,</span> 卖出<span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> prices<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#相比于122，增加了第三条状态</span>        <span class="token comment" spellcheck="true"># dp[i][0]: 手上不持有股票，并且处于冷冻期中的累计最大收益</span>        <span class="token comment" spellcheck="true"># dp[i][1]: 手上持有股票的最大收益</span>        <span class="token comment" spellcheck="true"># dp[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#处于冷冻期，必定是前一天做出了卖出的操作</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#持有股票，可能是前一天持有，也可能是在非冷冻期进行了买入操作</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#可能前一天是冷冻期，也可能前一天是非冷冻期，不可能在前一天进行卖出的操作</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><strong>+ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></strong><br>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：prices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出：<span class="token number">6</span>解释：在第 <span class="token number">4</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">0</span>）的时候买入，在第 <span class="token number">6</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">3</span>）的时候卖出，这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">3</span><span class="token operator">-</span><span class="token number">0</span> <span class="token operator">=</span> <span class="token number">3</span> 。     随后，在第 <span class="token number">7</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">1</span>）的时候买入，在第 <span class="token number">8</span> 天 （股票价格 <span class="token operator">=</span> <span class="token number">4</span>）的时候卖出，这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">4</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3</span> 。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#相比于122，增加了第三个状态</span>        <span class="token comment" spellcheck="true"># dp[i][0][k]: 手上不持有股票，并且已经交易k次的最大收益</span>        <span class="token comment" spellcheck="true"># dp[i][1][k]: 手上持有股票，并且已经交易k次的最大收益</span>        <span class="token comment" spellcheck="true"># 此时k取值为0,1,2</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;力扣的股票问题一共有6道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/b</summary>
      
    
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer12-13</title>
    <link href="http://dennis174698.github.io/2020/11/10/%E5%89%91%E6%8C%87offer12-13/"/>
    <id>http://dennis174698.github.io/2020/11/10/%E5%89%91%E6%8C%87offer12-13/</id>
    <published>2020-11-10T05:12:57.000Z</published>
    <updated>2020-12-09T14:07:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span><span class="token string">"ABCESFCSADEE"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">"ABCCED"</span>输出<span class="token punctuation">:</span>true</code></pre><p>###题解:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> matrix<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> <span class="token operator">not</span> path<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        x <span class="token operator">=</span> <span class="token punctuation">[</span>list<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>cols<span class="token operator">*</span>i<span class="token punctuation">:</span>cols<span class="token operator">*</span>i<span class="token operator">+</span>cols<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rows<span class="token punctuation">)</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">#构建二维数组</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rows<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>cols<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>x<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>matrix<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#如果找到路径开头字母</span>            <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>           <span class="token comment" spellcheck="true">#并且后面不为空，开始递归</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>                  matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span>       <span class="token comment" spellcheck="true">#将路径已经遍历过的路径设为空，避免'SAS'这种情况</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true">#左</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#右</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> j<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token number">-1</span><span class="token punctuation">,</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token comment" spellcheck="true"># 上    </span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#下</span>                <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true">#             return True</span>            matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>     <span class="token comment" spellcheck="true">#如果四个方位都没找到路径,将矩阵元素设为初始值</span><span class="token comment" spellcheck="true">#             return False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span>输出<span class="token punctuation">:</span><span class="token number">21</span></code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">cal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        sum <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> temp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            sum <span class="token operator">+=</span>temp<span class="token operator">%</span><span class="token number">10</span>            temp <span class="token operator">=</span> temp<span class="token operator">/</span><span class="token number">10</span>        <span class="token keyword">return</span> sum    <span class="token keyword">def</span> <span class="token function">movingCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> threshold<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">:</span>        num <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rows<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>cols<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>cal<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>cal<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">&lt;=</span>threshold<span class="token punctuation">)</span><span class="token punctuation">:</span>                    num <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">elif</span> <span class="token punctuation">(</span>rows <span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span> cols <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> num        <span class="token keyword">return</span> num</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵</summary>
      
    
    
    
    <category term="算法" scheme="http://dennis174698.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://dennis174698.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://dennis174698.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>life&#39;s an open door</title>
    <link href="http://dennis174698.github.io/2020/10/23/life-s-an-open-door/"/>
    <id>http://dennis174698.github.io/2020/10/23/life-s-an-open-door/</id>
    <published>2020-10-23T09:55:06.000Z</published>
    <updated>2020-11-03T10:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Open-Door"><a href="#Open-Door" class="headerlink" title="Open Door"></a>Open Door</h2><p>I’ve seen mountains<br>I’ve seen breaches<br>Distant seas<br>Uncharted beaches<br>I’ve seen light<br>From many welcome ports<br><img src="/image/22.jpg"><br>I’ve been warmed on<br>Tropic islands<br>Lost in city’s<br>Sounds and slience<br>I’ve been found<br>On many golden shores<br><img src="/image/1.jpg"></p><p>I’ve lived the stories<br>Heartbreaks and glories<br>The happiness and the strife<br>The tears and the laughter<br>Of a life<br><img src="/image/2.jpg"></p><p>Lately I dreamed<br>I’ve tasted<br>All life’s treasures<br>But still my heart fills me<br>With pleasures</p><p>This life’s an open door</p><p><img src="/image/3.jpg"></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2923703&auto=1&height=66"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Open-Door&quot;&gt;&lt;a href=&quot;#Open-Door&quot; class=&quot;headerlink&quot; title=&quot;Open Door&quot;&gt;&lt;/a&gt;Open Door&lt;/h2&gt;&lt;p&gt;I’ve seen mountains&lt;br&gt;I’ve seen breaches&lt;</summary>
      
    
    
    
    <category term="杂事" scheme="http://dennis174698.github.io/categories/%E6%9D%82%E4%BA%8B/"/>
    
    
    <category term="杂事" scheme="http://dennis174698.github.io/tags/%E6%9D%82%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-有效的数独(medium)</title>
    <link href="http://dennis174698.github.io/2020/09/25/leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-medium/"/>
    <id>http://dennis174698.github.io/2020/09/25/leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-medium/</id>
    <published>2020-09-25T15:59:40.000Z</published>
    <updated>2020-09-26T00:04:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description"></a>Problem description</h3><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>1.数字 1-9 在每一行只能出现一次。<br>2.数字 1-9 在每一列只能出现一次。<br>3.数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p>示例1：</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">"5"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"5"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"4"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"5"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> true</code></pre><p>示例2：</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"5"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"4"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"5"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> false</code></pre><p>解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。<br>说明:</p><p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>给定数独序列只包含数字 1-9 和字符 ‘.’ 。<br>给定数独永远是 9x9 形式的。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>3个维度的字典：行，列，块。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">)</span><span class="token punctuation">:</span>        rows <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125; for i in range(9)]</span>        columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125; for i in range(9)]</span>        boxs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125; for i in range(9)]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                num <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">if</span> num <span class="token operator">!=</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    num <span class="token operator">=</span> int<span class="token punctuation">(</span>num<span class="token punctuation">)</span>                    boxIndex <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">//</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> j <span class="token operator">//</span> <span class="token number">3</span>                    rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                    columns<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span>columns<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                    boxs<span class="token punctuation">[</span>boxIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span>boxs<span class="token punctuation">[</span>boxIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                    <span class="token keyword">if</span> rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">or</span> columns<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">or</span> boxs<span class="token punctuation">[</span>boxIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Problem-description&quot;&gt;&lt;a href=&quot;#Problem-description&quot; class=&quot;headerlink&quot; title=&quot;Problem description&quot;&gt;&lt;/a&gt;Problem description&lt;/h3&gt;&lt;p&gt;判断</summary>
      
    
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="http://dennis174698.github.io/tags/leetcode/"/>
    
    <category term="medium" scheme="http://dennis174698.github.io/tags/medium/"/>
    
  </entry>
  
  <entry>
    <title>信条中的钳形行动</title>
    <link href="http://dennis174698.github.io/2020/09/12/%E4%BF%A1%E6%9D%A1%E4%B8%AD%E7%9A%84%E9%92%B3%E5%BD%A2%E8%A1%8C%E5%8A%A8/"/>
    <id>http://dennis174698.github.io/2020/09/12/%E4%BF%A1%E6%9D%A1%E4%B8%AD%E7%9A%84%E9%92%B3%E5%BD%A2%E8%A1%8C%E5%8A%A8/</id>
    <published>2020-09-12T07:07:16.000Z</published>
    <updated>2020-09-18T17:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>电影的信息量实在太大，对影片的一些想法和理解是出了影院才想通的。信条中的钳形行动非常有趣，也是理解影片的一个比较大的难点，在这里记录一下自己的理解和想法。</p><h3 id="时间流"><a href="#时间流" class="headerlink" title="时间流"></a>时间流</h3><p>虽然说影片里的人和物品时间倒退是基于物理中的熵增熵减，但是个人觉得用时间流来解释更方便理解。</p><p>如下图所示，对于两边的世界来说，时间流的正向都是从左到右的。而当人穿过装置时，就可以获得逆行于时间流的能力。也就是说在正常人的世界里，人可以先看到和感知14:00的时间和事件，后面才可以感受到15:00的时间和事件。而对逆行者，先看到和感知的是15:00的时间，当他一步步前进时，看到的是倒退的世界。如果正常人看逆行者，则会看到倒退一系列古怪的行为。<br><img src="/image/4.jpg"></p><h3 id="钳形行动"><a href="#钳形行动" class="headerlink" title="钳形行动"></a>钳形行动</h3><p>简单来说就是现在的自己，和在未来穿越到过去，也就是现在的自己，双方合作的行为。在萨托的行动中，未来的自己通过无线电给现在的发送信息，获得的信息只需要通过倒放即可还原。也可以说，行动开始前，行动的结果已经确定了。然而现在的人，仍然需要通过装置回到过去，以形成闭环。<br><img src="/image/6.jpg"></p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ol><li>钳形行动的第一个人 ，会不会没有未来的自己来提示？<br>时间可能没有起点和终点，就和数字没有最大和最小一样，总会有一个未来的自己在你更前面。</li><li>弹孔是什么时候存在的?<br>其实不难理解，比如逆行者在14：00 打下了弹孔，继续逆行，那么在14：00 之前，比如说13:30会有人发现它，并将其修复，那么在13:30之前弹孔都不会存在。而在13:30之后，越来越接近14:00，弹孔会慢慢出现，并在子弹收回的时候彻底消失。对于正常世界的人，永远看不到弹孔的形成。</li><li>为什么进入装置的时候会有时候看到两个人，有时候会消失？<br>看到两人的情况为左半部分，逆行者比如在14:00进入装置，14:00之后会回到正常状态，与时间流同向，所以就会有一个14:00-14:30的正向自己，和14:30-14:00的逆向自己，而对其他人来说，就会看到装置里冲出一个正常人，和一个在14:00-14:30倒退的人。<br>消失的情况为右半部分，如果在15:00通过装置并回到了过去，在其他人看来，会有一个14:30-15:00的倒退人和一个正常人同时进入装置并消失。因为正常人的时间流继续经过了15:00并且无法观测到过去。<br><img src="/image/5.jpg"></li><li>未来的人能对过去的人进行干扰吗？<br>是可以的，只不过对现在的你来说，干扰已经完成，只不过现在的你还需要做同一份动作。还可以做这么一种假设，时光机已经发明过了，世界已经被修改了无数次，由于世界的规律是由波动趋于平稳，无数次的危机也许就像影片里的一样，不过是某个无关紧要的小爆炸罢了。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;电影的信息量实在太大，对影片的一些想法和理解是出了影院才想通的。信条中的钳形行动非常有趣，也是理解影片的一个比较大的难点，在这里记录一下自己的理解和想法。&lt;/p&gt;
&lt;h3 id=&quot;时间流&quot;&gt;&lt;a href=&quot;#时间流&quot; class=&quot;headerlink&quot; title=&quot;时</summary>
      
    
    
    
    <category term="杂事" scheme="http://dennis174698.github.io/categories/%E6%9D%82%E4%BA%8B/"/>
    
    
    <category term="杂事" scheme="http://dennis174698.github.io/tags/%E6%9D%82%E4%BA%8B/"/>
    
    <category term="电影" scheme="http://dennis174698.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>无题</title>
    <link href="http://dennis174698.github.io/2020/09/01/%E6%97%A0%E9%A2%98/"/>
    <id>http://dennis174698.github.io/2020/09/01/%E6%97%A0%E9%A2%98/</id>
    <published>2020-09-01T14:57:09.000Z</published>
    <updated>2020-09-26T00:14:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="美好的回忆，似乎也可以变成梦魇"><a href="#美好的回忆，似乎也可以变成梦魇" class="headerlink" title="美好的回忆，似乎也可以变成梦魇"></a>美好的回忆，似乎也可以变成梦魇</h4><p><img src="/image/EIYG5432.JPG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;美好的回忆，似乎也可以变成梦魇&quot;&gt;&lt;a href=&quot;#美好的回忆，似乎也可以变成梦魇&quot; class=&quot;headerlink&quot; title=&quot;美好的回忆，似乎也可以变成梦魇&quot;&gt;&lt;/a&gt;美好的回忆，似乎也可以变成梦魇&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/image/E</summary>
      
    
    
    
    <category term="杂事" scheme="http://dennis174698.github.io/categories/%E6%9D%82%E4%BA%8B/"/>
    
    
    <category term="杂事" scheme="http://dennis174698.github.io/tags/%E6%9D%82%E4%BA%8B/"/>
    
  </entry>
  
</feed>
