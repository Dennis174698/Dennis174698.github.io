<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>crush</title>
      <link href="/2021/07/16/crush/"/>
      <url>/2021/07/16/crush/</url>
      
        <content type="html"><![CDATA[<p>冰川融化的第一滴水，<br>破晓前的第一声鸟叫，<br>森林里忽然落下的断枝，<br>夜空中划过了一颗流星。</p><p><img src="/image/flower.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 杂事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发（二）</title>
      <link href="/2021/07/01/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/07/01/Java%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发(一)</title>
      <link href="/2021/06/03/Java%E5%B9%B6%E5%8F%91/"/>
      <url>/2021/06/03/Java%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h2><h3 id="1-1进程"><a href="#1-1进程" class="headerlink" title="1.1进程"></a>1.1进程</h3><ul><li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</li><li>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</li></ul><p><strong>进程通信</strong></p><ul><li><p><strong>进程通信</strong>：</p></li><li><p><strong>有名管道。</strong>也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p></li><li><p><strong>信号量(semaphore)。</strong>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p></li><li><p><strong>消息队列(messagequeue)。</strong>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p><strong>信号 (sinal)。</strong>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p></li><li><p><strong>共享内存(shared memory)。</strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p></li><li><p><strong>套接字(socket)。</strong>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p></li></ul><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h3><ul><li><p>线程是进程的一个实体，是CPU调度和分配的基本单位。进程是线程的容器，一个进程在运行时可能产生多个线程，一个进程下的线程共享进程所拥有的全部资源。</p></li><li><p><strong>线程通信</strong></p></li><li><p><strong>锁机制：</strong>包括互斥锁、条件变量、读写锁。互斥锁提供了以排他方式防止数据结构被并发修改的方法。读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。wait/notify 等待 。。Volatile 内存共享。。CountDownLatch 并发工具。。CyclicBarrier 并发工具</p></li><li><p><strong>信号量机制(Semaphore)。</strong> 包括无名线程信号量和命名线程信号量。</p></li><li><p><strong>信号机制(Signal)。</strong> 类似进程间的信号处理。</p></li><li><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p></li></ul><h3 id="1-3-线程与进程的区别"><a href="#1-3-线程与进程的区别" class="headerlink" title="1.3 线程与进程的区别"></a>1.3 线程与进程的区别</h3><ul><li>线程是比进程更轻量级的调度执行单位，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址，文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。</li><li>多进程中每个进程有自己的地址空间，线程则共享地址空间。</li><li>所有其他区别都是因为这个区别产生的。比如说：<ul><li>地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</li><li>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</li></ul></li><li>线程是处理器调度的基本单位,但进程不是</li><li>二者均可并发执行</li><li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</li><li>速度。线程产生的速度快，通讯快，切换快，因为他们处于同一地址空间。</li><li>线程的资源利用率好。</li><li>线程使用公共变量或者内存的时候需要同步机制，但进程不用。</li><li>而他们通信方式的差异也仍然是由于这个根本原因造成的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合类</title>
      <link href="/2021/05/29/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2021/05/29/%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-常用集合"><a href="#Java-常用集合" class="headerlink" title="Java 常用集合"></a>Java 常用集合</h1><p><img src="/image/java/jihe.png"></p><h2 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h2><h3 id="1-1-List基本实现"><a href="#1-1-List基本实现" class="headerlink" title="1.1 List基本实现"></a>1.1 List基本实现</h3><ul><li>ArrayList: List 主要实现类，底层使用Object[]存储，适合频繁查询工作，线程不安全</li><li>Vector: 古老实现类，线程安全，</li><li>LinkedList: 底层使用双向链表结构,JDK1.7取消了循环<ul><li>getFirst（） 和element（） 完全一样，都返回第一个元素。如果为空，抛NoSuchElementException.</li><li>peek（） 方法与上诉类似，只时列表为空返回null</li><li>removeFirst（） 和 remove（） 类似，移除并返回列表的头，只是列表为空抛出NoSuchElementException。</li><li>poll（） 同样移除并返回列表头，只是列表为空返回Null</li></ul></li><li>Stack: 栈结构,pop（）、push（）、 peek（）方法，其中peek（）返回栈顶元素，而不将其移除。</li></ul><h3 id="1-2-ArrayList扩容与源码分析"><a href="#1-2-ArrayList扩容与源码分析" class="headerlink" title="1.2 ArrayList扩容与源码分析"></a>1.2 ArrayList扩容与源码分析</h3><pre><code>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：   /**     * 默认初始容量大小     */    private static final int DEFAULT_CAPACITY = 10;    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;    /**     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)     */    public ArrayList() &#123;        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    &#125;    /**     * 带初始容量参数的构造函数。（用户自己指定容量）     */    public ArrayList(int initialCapacity) &#123;        if (initialCapacity &gt; 0) &#123;//初始容量大于0            //创建initialCapacity大小的数组            this.elementData = new Object[initialCapacity];        &#125; else if (initialCapacity == 0) &#123;//初始容量等于0            //创建空数组            this.elementData = EMPTY_ELEMENTDATA;        &#125; else &#123;//初始容量小于0，抛出异常            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                               initialCapacity);        &#125;    &#125;   /**    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回    *如果指定的集合为null，throws NullPointerException。    */     public ArrayList(Collection&lt;? extends E&gt; c) &#123;        elementData = c.toArray();        if ((size = elementData.length) != 0) &#123;            // c.toArray might (incorrectly) not return Object[] (see 6260652)            if (elementData.getClass() != Object[].class)                elementData = Arrays.copyOf(elementData, size, Object[].class);        &#125; else &#123;            // replace with empty array.            this.elementData = EMPTY_ELEMENTDATA;        &#125;    &#125;</code></pre><ul><li>无参初始化容量为10</li><li>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</li></ul><h3 id="1-3-LinkedList-源码"><a href="#1-3-LinkedList-源码" class="headerlink" title="1.3 LinkedList 源码"></a>1.3 LinkedList 源码</h3><p>定义了一个内部的Node 节点，基于双向链表实现，使用 Node 存储链表节点信息。<br>相关操作：</p><ul><li><p>getFirst() 和element() 完全一样，都返回第一个元素。如果为空，抛NoSuchElementException.</p></li><li><p>peek() 方法与上诉类似，只时列表为空返回null</p></li><li><p>removeFirst() 和 remove() 类似，移除并返回列表的头，只是列表为空抛出NoSuchElementException。</p></li><li><p>poll() 同样移除并返回列表头，只是列表为空返回Null</p><pre><code>private static class Node&lt;E&gt; &#123;      E item;      Node&lt;E&gt; next;      Node&lt;E&gt; prev;      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;          this.item = element;          this.next = next;          this.prev = prev;      &#125;  &#125;</code></pre></li><li><p>add（）方法有<strong>add（E e）</strong> 方法：将元素添加到链表尾部，<strong>add（int index,E e）</strong>：在指定位置添加元素</p></li><li><p><strong>addAll（Collection c ）</strong>：将集合插入到链表尾部,<strong>addAll（int index, Collection c）</strong>： 将集合从指定位置开始插入</p></li><li><p><strong>get(int index)：</strong> 根据指定索引返回数据,**int indexOf(Object o)**： 从头遍历找 **int lastIndexOf(Object o)**： 从尾遍历找, **remove(int index)**：删除指定位置的元素</p></li></ul><h3 id="1-4-ArrayList与LinkedList区别"><a href="#1-4-ArrayList与LinkedList区别" class="headerlink" title="1.4 ArrayList与LinkedList区别"></a>1.4 ArrayList与LinkedList区别</h3><p><strong>1. 是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）<br><strong>3. 插入和删除是否受元素位置的影响：</strong><br>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add（E e）方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O（1）。但是如果要在指定位置 i 插入和删除元素的话（add（int index, E element））时间复杂度就为 O（n-i）。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的（n-i）个元素都要执行向后位/向前移一位的操作。<br>LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add（E e）、addFirst（E e）、addLast（E e）、removeFirst（） 、 removeLast（）），近似 O（1），如果是要在指定位置 i 插入和删除元素的话（add（int index, E element），remove（Object o）） 时间复杂度近似为 O（n） ，因为需要先移动到指定位置再插入。<br><strong>4. 是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象（对应于get（int index）方法）。<br><strong>5. 内存空间占用：</strong> ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p><h2 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h2><ul><li>HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》</li><li>Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>ConcurrentHashMap: 线程安全的Map.</li><li>TreeMap: 基于红黑树的实现（自平衡的排序二叉树）。“键”或“键值对”的次序是由Comparable或Comparator决定的。TreeMap是唯一带有subMap()方法的Map，可以返回一个子树。</li><li>WeakHashMap： 弱键映射，允许设释放射所指对象。被垃圾收集器回收。</li><li>ConcurrentHashMap: 线程安全的Map.</li><li>IdentityHashMap：使用==代替equals()对“键”进行比较的散列映射。</li><li>sortedMap: 排序的Map，现阶段TreeMap是其唯一实现。</li><li>EnumMap:要求键必须来自一个Enum。</li></ul><h3 id="2-1-HashMap"><a href="#2-1-HashMap" class="headerlink" title="2.1 HashMap"></a>2.1 HashMap</h3><ul><li><strong>底层实现</strong><br>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。</li></ul><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 （n - 1） &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><pre><code>1.8 的hash方法    static final int hash(Object key) &#123;      int h;      // key.hashCode()：返回散列值也就是hashcode      // ^ ：按位异或      // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);  &#125;</code></pre><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;    // 序列号    private static final long serialVersionUID = 362498820763181265L;    // 默认的初始容量是16    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;    // 最大容量    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    // 默认的填充因子    static final float DEFAULT_LOAD_FACTOR = 0.75f;    // 当桶(bucket)上的结点数大于这个值时会转成红黑树    static final int TREEIFY_THRESHOLD = 8;    // 当桶(bucket)上的结点数小于这个值时树转链表    static final int UNTREEIFY_THRESHOLD = 6;    // 桶中结构转化为红黑树对应的table的最小大小    static final int MIN_TREEIFY_CAPACITY = 64;    // 存储元素的数组，总是2的幂次倍    transient Node&lt;k,v&gt;[] table;    // 存放具体元素的集    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;    // 存放元素的个数，注意这个不等于数组的长度。    transient int size;    // 每次扩容和更改map结构的计数器    transient int modCount;    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容    int threshold;    // 加载因子    final float loadFactor;&#125;</code></pre><ul><li><strong>loadFactor 加载因子</strong></li></ul><p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><ul><li><strong>threshold</strong></li></ul><p>threshold = capacity * loadFactor，当 Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</p><ul><li><strong>扩容</strong></li></ul><ol><li>计算扩容新的table长度size 与threshold 的长度</li><li>遍历旧table，如果节点，无哈希冲突的情况，e.hash&amp;(newCap-1)直接定位到新的位置。</li><li>出现哈希冲突的情况，由于每次扩容的大小默认为2的n次方，因此重散列的位置只会为当前位置或者当前位置+旧数组大小两个位置。</li><li>如果节点存在哈希冲突，则根据位运算计算最新的位置是否为0，为0表示无需移动节点。为1表示移动到oldCap+j的位置。</li><li>针对出现红黑树的哈希冲突，同理。此处针对红黑树冲突的需要判断重散列的节点是否需要重新建立红黑树。</li><li>如果初始化容量大小部位2的幂次方，那么在初始化的时候，会计算threshold为大于初始化数的最近2的幂次方数，在实际使用的时候声明为table的大小。※</li></ol><ul><li><strong>红黑树</strong></li></ul><p>红黑树： 红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。<br>三种操作：左旋、右旋和变色。</li></ul><p><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。<br><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。<br><strong>变色</strong>：结点的颜色由红变黑或由黑变红。 <a href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></p><p><img src="/image/java/rbtree.png"></p><ul><li><strong>put操作</strong></li></ul><ol><li>首先判断table是否需要扩容，若需要进行扩容操作</li><li>计算当前元素hash经过散列后是否有元素存在，若不存在元素直接添加。</li><li>若存在元素，分下面两个判断<br>替换：若旧元素的hash值与新添加元素一致，且新添加Node 的key调用equals方法一致，则直接替换旧节点。<br>拉链法：<br>普通链表：循环判断链表节点是否为key相同替换情况，若均不是需要替换情况，则定位到链表尾部添加新节点。<br>红黑树：树形遍历判断是否存在，不存在添加。</li></ol><ul><li><strong>hashmap红黑树查找</strong></li></ul><p><strong>为什么使用红黑树：</strong> 当HashMap中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候HashMap就相当于一个单链表，假如单链表有n个元素，遍历的时间复杂度就是O(n)，完全失去了它的优势。 针对这种情况，JDK1.8中引入了红黑树来优化这个问题，为什么不引入二叉查找树呢？因为二叉查找树的一般操作的执行时间为O(lgn)，但是二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。与单链表一样。 所以此时我们需要红黑树它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。<br>红黑树建立是基于Hash的大小来建立的。这里的hashcode 为hashMap换算过的hash。hash小的为左子树， hash 大的为右子树</p><p>针对hash重复的情况：</p><p>使用equal的方法进行匹配，相同返回。<br>若存在左节点或右节点缺失，则直接进入未缺失的节点查找。（left==null ==&gt; findByRight)，均不存在返回null。<br>左右子节点均存在，判断是否为相同的class，及class是否继承comparable接口，<br>若为相同的class且都继承则直接通过comparable判断左右节点。<br>若不同的class、无继承comparable接口或者经过comparable接口比较的结果相等。<br>递归调用左节点查找，若未找到，递归调用右节点查找。</p><pre><code> final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;    TreeNode&lt;K,V&gt; p = this;    do &#123;        int ph, dir; K pk;        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;        if ((ph = p.hash) &gt; h)            p = pl;        else if (ph &lt; h)            p = pr;        // hash 相同 使用equal比较        else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))            return p;        // 左右子树缺失，直接进入存在子树的部分        else if (pl == null)            p = pr;        else if (pr == null)            p = pl;        // 基于class的比较，若都继承comparable接口，则使用compareTo比较        // 若class 均不继承comparable 接口，或者compare接口比较后相同，进入左右子树递归查询。        else if ((kc != null ||                  (kc = comparableClassFor(k)) != null) &amp;&amp;                 (dir = compareComparables(kc, k, pk)) != 0)            p = (dir &lt; 0) ? pl : pr;        else if ((q = pr.find(h, k, kc)) != null)            return q;        else            p = pl;    &#125; while (p != null);    return null;&#125;</code></pre><p>针对建立红黑树或者添加树节点的情况</p><ul><li><p>若使用equal及class 的compare 均无法确定添加节点的方向</p></li><li><p>使用对象的类名进行判断，若类名依然相同，则使用System根据对象地址换算的hashcode编码判断添加方向。<br>static int tieBreakOrder(Object a, Object b) {</p><pre><code>  int d;  if (a == null || b == null ||      (d = a.getClass().getName().       compareTo(b.getClass().getName())) == 0)      d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?           -1 : 1);  return d;</code></pre><p>  }</p></li><li><p><strong>HashMap遍历方法</strong></p><ul><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历。</li></ul></li></ul><p>如果从性能方面考虑，我们应该尽量使用 lambda 或者是 entrySet 来遍历 Map 集合。</p><p>EntrySet 之所以比 KeySet 的性能高是因为，KeySet 在循环时使用了 map.get（key），而 map.get（key） 相当于又遍历了一遍 Map 集合去查询 key 所对应的值。为什么要用“又”这个词？那是因为在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用 map.get（key） 查询时，相当于遍历了两遍。<br>而 EntrySet 只遍历了一遍 Map 集合，之后通过代码“Entry&lt;Integer, String&gt; entry = iterator.next（）”把对象的 key 和 value 值都放入到了 Entry 对象中，因此再获取 key 和 value 值时就无需再遍历 Map 集合，只需要从 Entry 对象中取值就可以了。<br>所以，EntrySet 的性能比 KeySet 的性能高出了一倍，因为 KeySet 相当于循环了两遍 Map 集合，而 EntrySet 只循环了一遍。</p><p><a href="https://juejin.cn/post/6844904144331866119">https://juejin.cn/post/6844904144331866119</a></p><h3 id="2-2-concurrentHashMap"><a href="#2-2-concurrentHashMap" class="headerlink" title="2.2 concurrentHashMap"></a>2.2 concurrentHashMap</h3><ul><li>数据结构:synchronized+CAS+Node+红黑树,Node的val和next都用volatile修饰,保证可见性</li><li>查找,替换,赋值操作都使用CAS</li><li>锁:锁链表的head节点,不影响其他元素的读写,锁粒度更细,效率更高,扩容时,阻塞所有的读写<br>操作、并发扩容</li><li>读操作无锁:<br>Node的val和next使用volatile修饰,读写线程对该变量互相可见<br>数组用volatile修饰,保证扩容时被读线程感知</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2021/05/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/05/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/image/java/sort.png"></p><ul><li>相关资料：<a href="https://www.jianshu.com/p/47170b1ced23">https://www.jianshu.com/p/47170b1ced23</a></li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>比较相邻的元素，如果前一个比后一个大，交换两个元素</li><li>从最开始的一对到最后一对，这样最后的元素就是数组里最大的数</li><li>重复以上步骤，除了最后一个</li><li>重复步骤1-3，知道排序完成。</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#python实现</span><span class="token keyword">def</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> nums    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token keyword">return</span> nums        </code></pre><pre><code>//Java实现public static int[] bubbleSort(int[] nums)&#123;    n = nums.lengthl    if(n==0)&#123;return nums;&#125;    for(int i=0;i&lt;n;i++)&#123;    for(int j=0;j&lt;n-1-i;j++)&#123;        if(nums[j]&gt;nums[j+1])&#123;        int tmp = nums[j+1];        nums[j+1] = nums[j];        nums[j] = tmp;        &#125;    &#125;    &#125;&#125;</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>从未排序的序列中找到最大（小）元素，放入排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#python 实现</span><span class="token keyword">def</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> nums    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    minIndex <span class="token operator">=</span> i    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">:</span>        minIndex <span class="token operator">=</span> j    tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span>      <span class="token comment" spellcheck="true">#最小元素和无序区第一个数交换</span>    nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp    <span class="token keyword">return</span> nums</code></pre><pre><code>//java实现public static int[] selectSort(int[] nums)&#123;    n = nums.length;    if(n==0)&#123;return nums;&#125;    for(int i=0;i&lt;n;i++)&#123;    int minIndex=i;    for(int j=i;j&lt;n;j++)&#123;        if(nums[minIndex]&lt;nums[j])&#123;minIndex = j;&#125;            &#125;        int tmp=nums[minIndex];        nums[minIndex] = nums[i];        nums[i] = tmp;    &#125;    return nums;&#125;</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>直接插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>一般来说，直接插入排序都采用in-place（原地算法）在数组上实现。具体算法描述如下：<br>1）从第一个元素开始，该元素可以认为已经被排序；<br>2）取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>3）如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>5）将新元素插入到该位置后；<br>6）重复步骤2~5。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#python实现</span><span class="token keyword">def</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> nums    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">#取出未排序部分的第一个元素</span>        preIndex <span class="token operator">=</span> i<span class="token number">-1</span>      <span class="token comment" spellcheck="true">#排序部分最后一位元素</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>preIndex<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> cur<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#跟前一位元素对比</span>            nums<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span>              preIndex<span class="token operator">-=</span><span class="token number">1</span>                            <span class="token comment" spellcheck="true">#从后往前比较</span>        nums<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> cur                     <span class="token comment" spellcheck="true">#插入元素</span>    <span class="token keyword">return</span> nums    </code></pre><pre><code>public static int[] insertionSort(int[] nums )&#123;    int n = nums.length;    if(n==0)&#123;return nums;&#125;    int cur;    for(int i=1;i&lt;n;i++)&#123;        cur = nums[i];        preIndex = i-1;        while(preIndex&gt;=0 &amp;&amp; cur&lt;nums[preIndex])&#123;            nums[preIndex+1]=nums[preIndex];            preIndex--;        &#125;        &#125;        nums[preIndex+1] = cur;&#125;</code></pre><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>直接插入排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。<br>最好情况：如果待排序元素本来是正序的，比较和移动元素的次数分别是 (n - 1) 和 0，因此最好情况的时间复杂度为O(n)。<br>最坏情况：如果待排序元素本来是逆序的，需要进行 (n - 1) 趟排序，所需比较和移动次数分别为 n * (n - 1) / 2和 n * (n - 1) / 2。因此最坏情况下的时间复杂度为O(n2)。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p>1）把长度为 n 的输入序列分成两个长度为 n / 2 的子序列；<br>2）对这两个子序列分别采用归并排序；<br>3）将两个排序好的子序列合并成一个最终的排序序列。</p><p>时间复杂度稳定为O(nlogn),空间复杂度O(n)，递归引用空间</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> nums    mid <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>        left <span class="token operator">=</span> mergeSort<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>    right <span class="token operator">=</span> mergeSort<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> merge<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""合并两个已拍好的列表，产生一个新的已排序好的列表"""</span>    result<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    i <span class="token operator">=</span> <span class="token number">0</span>    j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">#队列表中的两个元素两两对比</span>    <span class="token comment" spellcheck="true">#将最小的元素，放到result中，并对当前下标+1</span>    <span class="token keyword">while</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        i<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        j<span class="token operator">+=</span><span class="token number">1</span>    result <span class="token operator">+=</span> left<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span>    result <span class="token operator">+=</span> right<span class="token punctuation">[</span>j<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> result</code></pre><pre><code>public static int[] mergeSort(int[] nums)&#123;    if(nums.length&lt;=1)&#123;    return nums;    &#125;    int mid = nums.length/2;    int[] left = Arrays.copyOfRange(nums,0,mid);    int[] right = Arrays.copyOfRange(nums,mid,nums.length);        return merge(mergeSort(left),mergeSort(right));&#125;public static int[] merge(int[] left, int[] right)&#123;    int[] result = new int[left.length + right.length];    int i=0,j=0,k=0;    while (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;            if (left[i] &lt;= right[j]) &#123;                result[k++] = left[i++];            &#125; else &#123;                result[k++] = right[j++];            &#125;        &#125;        while (i &lt; left.length) &#123;            result[k++] = left[i++];        &#125;        while (j &lt; right.length) &#123;            result[k++] = right[j++];        &#125;        return result;&#125;</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><p>快速排序使用分治法来把一个数列分为两个子数列。具体算法描述如下：<br>1）从数列中挑出一个元素，称为 “基准”（pivot）；<br>2）重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。这称为分区（partition）操作；<br>3）递归地（recursive）对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> nums    <span class="token keyword">else</span><span class="token punctuation">:</span>    cur <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    less <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">&lt;</span>cur<span class="token punctuation">]</span>    greater <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">>=</span>cur<span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>quicksort<span class="token punctuation">(</span>less<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">+</span>quicksort<span class="token punctuation">(</span>greater<span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><p>堆排序是一种树形选择排序方法，它利用了堆这种数据结构。在排序的过程中，将array[0，…，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大（最小）的元素。</p><p>② 概念<br>堆：堆是一种完全二叉树，且满足所有父节点的值均大于等于（或小于等于）其子节点的值。<br>大根堆（最大堆）：满足所有父节点的值均大于等于其子节点的值的堆称为大根堆，堆顶元素是堆中元素的最大值。<br>小根堆（最小堆）：满足所有父节点的值均小于等于其子节点的值的堆称为小根堆，堆顶元素是堆中元素的最小值。<br>堆的顺序存储结构：使用顺序数据结构（数组）存储堆，表示方法为：<br>1.数组按层序遍历的顺序存放完全二叉树的结点，下标为 0 处为堆顶，下标为 len - 1 处为堆尾。<br>2.结点 i 如果存在左孩子（下标不超过 len - 1 就存在），左孩子的下标为（2 * i + 1）；如果存在右孩子，右孩子的下标为（2 * i + 2）。结点 i 的父结点下标为 (i - 1) / 2 (下标为 0 的结点除外，它没有父结点)。最后一个非叶子结点即为堆尾元素的父结点，下标为 (len - 1 - 1) / 2 = (len - 2) / 2。</p><p>③ 算法描述<br>1）将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>2）将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>3）由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。</p><pre><code>//声明全局变量，用于记录数组array的长度；static int len;/** * 堆排序算法 * @param array * @return */public static int[] HeapSort(int[] array) &#123;        len = array.length;        if (len == 0) return array;        //1.构建一个大根堆        buildMaxHeap(array);        //2.循环将堆顶（最大值）与堆尾交换，删除堆尾元素，然后重新调整大根堆        while (len &gt; 0) &#123;            swap(array, 0, len - 1);            len--; //原先的堆尾进入有序区，删除堆尾元素            adjustHeap(array, 0); //重新调整大根堆        &#125;        return array; &#125; /**   * 自顶向下调整以 i 为根的堆为大根堆   * @param array   * @param i   */public static void adjustHeap(int[] array, int i) &#123;        int maxIndex = i;        //如果有左子树，且左子树大于父节点，则将最大指针指向左子树        if (2 * i + 1 &lt; len &amp;&amp; array[2 * i + 1] &gt; array[maxIndex])            maxIndex = 2 * i + 1;        //如果有右子树，且右子树大于父节点，则将最大指针指向右子树        if (2 * i + 2 &lt; len &amp;&amp; array[2 * i + 2] &gt; array[maxIndex])            maxIndex = 2 * i + 2;        //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。        if (maxIndex != i) &#123;            swap(array, maxIndex, i);            adjustHeap(array, maxIndex);        &#125; &#125; /**  * 自底向上构建初始大根堆  * @param array  */ public static void buildMaxHeap(int[] array) &#123;        //从最后一个非叶子节点开始自底向上构造大根堆        for (int i = (len - 2) / 2; i &gt;= 0; i--) &#123;             adjustHeap(array, i);        &#125; &#125;</code></pre><h2 id="二分查找（补充）"><a href="#二分查找（补充）" class="headerlink" title="二分查找（补充）"></a>二分查找（补充）</h2><pre><code>public statin int binarySearch(int[] arr, int target)&#123;    int low = 0;    int high = arr.length -1;    int mid = 0;    if(target&lt;arr[low] || target&gt;arr[high]||low&gt;high)&#123;return -1;&#125;        while(low&lt;=high)&#123;        mid = low+(high-low)/2; //避免int溢出        if(arr[mid]&gt;target)&#123;             high = mid-1;       //大于 -1    &#125;    if(arr[mid]&lt;target)&#123;     //小于+1        low = mid+1;    &#125;    else&#123;return mid;&#125;    &#125;    return -1;&#125;</code></pre><ul><li><a href="https://blog.csdn.net/bandaoyu/article/details/106596449?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&spm=1001.2101.3001.4242">算法详解二分查找算法（思路很简单，细节是魔鬼）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java I/O</title>
      <link href="/2021/05/24/Java-IO/"/>
      <url>/2021/05/24/Java-IO/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-I-o"><a href="#Java-I-o" class="headerlink" title="Java I/o"></a>Java I/o</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Java 的I/O大概可以分成一下几类：</p><ol><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ol><p><img src="/image/java/io.png"><br>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p><p>InputStream 是抽象组件；</p><ul><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了文件字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。<br>InputStream的作用是用来表示那些从不同数据源产生输入的类。</li></ul><ol><li>字节数组</li><li>String对象</li><li>文件</li><li>“管道“，工作方式与实际管道类似，即一端输入另一端输出</li><li>其他数据源，如Internet连接等<br>Reader 与 Writer</li></ol><ul><li>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</li><li>InputStreamReader 实现从字节流解码成字符流；</li><li>OutputStreamWriter 实现字符流编码成为字节流。</li></ul><h2 id="常见的I-O模型对比"><a href="#常见的I-O模型对比" class="headerlink" title="常见的I/O模型对比"></a>常见的I/O模型对比</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a><strong>BIO</strong></h3><p>同步阻塞IO模型，当应用程序发起read之后，会一直阻塞，知道内核将数据准备就绪并把数据拷贝到用户空间，程序才会继续运行。<br><img src="/image/java/bio.png"></p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a><strong>NIO</strong></h3><p>NIO模式下，系统调用read，如果发现没数据已经到达，就会立刻返回-1。使用轮询的方式，不断的尝试有没有数据到达。没有得到数据就等一小会再试继续轮询。</p><p>NIO解决了线程阻塞的问题 ，但是会带来两个新问题：</p><ul><li>如果有IO连接都要检查，那么就得一个一个的read。这会带来大量的线程上下文切换（read是系统调用，每调用一次就得在用户态和核心态切换一次）</li><li>轮询的休息等待时间无法确定。这里是要猜多久之后数据才能到。等待时间设的太长，程序响应延迟就过大；设的太短，就会造成过于频繁的重试，干耗CPU而已。</li></ul><p><img src="/image/java/nio1.png"></p><h3 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a><strong>多路复用IO</strong></h3><p>多路复用使用select,poll,epoll函数实现，主要是将多个进程的IO注册到同一管道上统一管理。管道会统一和内核进行交互，告诉操作系统要监视这些IO是否有事件发生。<br><img src="/image/java/nio2.png"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。<br>特点及相关说明：</p><ul><li>IO多路复用是要和NIO一起使用的。尽管在操作系统级别，NIO和IO多路复用是两个相对独立的事情。也可以只用IO多路复用 + BIO，这时效果还是当前线程被卡住，没有达到IO多路复用的通知请求到来的效果。</li><li>IO多路复用说的是多个Socket或IO连接，只不过操作系统是一起监听他们的事件而已。</li></ul><p>多个数据流共享同一个TCP连接的场景的确是有，比如Http2 Multiplexing就是指Http2通讯中多个逻辑的数据流共享同一个TCP连接。但这与IO多路复用是完全不同的问题。</p><ul><li>IO多路复用的关键API调用(select，poll，epoll_wait）总是Block的</li><li>IO多路复用和NIO一起仅仅是解决了调度的问题，避免CPU在这个过程中的浪费，使系统的瓶颈更容易触达到网络带宽，而非CPU或者内存。要提高IO吞吐，还是提高硬件的容量（例如，用支持更大带宽的网线、网卡和交换机）和依靠并发传输（例如HDFS的数据多副本并发传输）。</li></ul><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a><strong>AIO</strong></h3><p>不会</p><h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h2><p>操作系统级别提供了一些接口来支持IO多路复用，最早的是select、poll，其后epoll是Linux下的IO多路复用的实现。</p><ul><li>select接口最早实现存在需要调用多次、线程不安全以及限制只能监视1024个链接的问题</li><li>poll接口修复了select函数的一些问题，但是依然不是线程安全的。</li><li>epoll接口修复了上述的问题，并且线程安全，会通知具体哪个连接有新数据。</li><li>epoll通过epoll_ctl()来注册一个文件描述符,一旦基于某个文件描述符就绪时,内核会采用类似callback的回调机制,迅速激活这个文件描述符,当进程调用epoll_wait()时便得到通知(不再需要遍历文件描述符,通过监听回调的机制,也是epoll的魅力)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2021/05/23/java/"/>
      <url>/2021/05/23/java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h2><h3 id="1-1-8种基本类型"><a href="#1-1-8种基本类型" class="headerlink" title="1.1 8种基本类型"></a>1.1 8种基本类型</h3><p><img src="/image/java/8.png"></p><h3 id="1-2-包装类型"><a href="#1-2-包装类型" class="headerlink" title="1.2 包装类型"></a>1.2 包装类型</h3><p>将简单类型包装为类,含有以下用途</p><ol><li>提供类的对象操作,如类型转换,进制转换等</li><li>集合不允许存放基本数据类型,使用包装类</li><li>包装类含有基本类型的相关属性,如最大值,最小值等</li></ol><p>包装类都为final不可继承</p><h3 id="1-3-装箱与拆箱"><a href="#1-3-装箱与拆箱" class="headerlink" title="1.3 装箱与拆箱"></a>1.3 装箱与拆箱</h3><p>Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)<br>int y = x;         // 拆箱 调用了 X.intValue()</p><p>new Integer(123) 和 Integer.valueOf(123) 区别<br>new Interger 新建了一个对象<br>.valueOf()会调用缓存池的对象,多次调用会取得同一对象的引用.</p><p>包装类型内存使用 private static class IntegerCache，声明一个内部使用的缓存池</p><p>如Integer中有个静态内部类IntegerCache，里面有个cache[],也就是Integer常量池，常量池的大小为一个字节（-128~127）<br>为啥把缓存设置为[-128，127]区间？性能和资源之间的权衡。 在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax= 来指定这个缓冲池的大小。<br>基本类型对应的缓冲池如下：</p><p>boolean values: true and false<br>all byte values<br>short values: between -128 and 127<br>int values: between -128 and 127<br>char: in the range \u0000 to \u007F</p><h3 id="1-4-String"><a href="#1-4-String" class="headerlink" title="1.4 String"></a>1.4 String</h3><p>String 被声明为final,不可继承,线程安全</p><ol><li><p>intern() 方法:<br>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；<br>否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p></li><li><p>运行效率<br>StringBuilder &gt; StringBuffer &gt; String<br>但是String str = “hello”+ “world”的效率就比 StringBuilder st = new StringBuilder().append(“hello”).append(“world”)要高</p></li><li><p>使用总结</p></li></ol><p><strong>少量数据:</strong> String<br><strong>单线程操作,字符缓冲区大量数据:</strong> Stringbuilder<br><strong>多线程操作,字符缓冲区大量数据:</strong> StringBuffer<br>4. 线程安全<br>String：对象定义后不可变，线程安全。<br>StringBuffer：是线程安全的（对调用方法加入同步锁），执行效率较慢，适用于多线程下操作字符串缓冲区大量数据。<br>StringBuilder：是线程不安全的，适用于单线程下操作字符串缓冲区大量数据。<br>5. 共同点<br>StringBuilder和StringBuffer有共同的父类AbstractStringBuilder（抽象类）。</p><p>　　StringBuilder和StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append（…）,只是StringBuffer会在方法上加上synchronized关键字进行同步。</p><pre><code>String a = &quot;hello2&quot;; 　  String b = &quot;hello&quot;;       String c = b + 2;       System.out.println((a == c));输出结果为:false。由于有符号引用的存在，所以  String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的String a = &quot;hello2&quot;;   　final String b = &quot;hello&quot;;       String c = b + 2;       System.out.println((a == c));输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问</code></pre><h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2.关键字"></a>2.关键字</h2><h3 id="2-1-final"><a href="#2-1-final" class="headerlink" title="2.1 final"></a>2.1 final</h3><ul><li><strong>数据</strong>:: 声明数据为常量,可以是编译时常量,也可以是在运行时被初始化后不能改变的常量</li><li><strong>基本类型:</strong>, 数据不变</li><li><strong>引用类型:</strong>, 是引用不变,但被引用的对象可以被改变</li><li>被修饰的数据在jvm常量池中</li><li>被修饰的类不能被继承,方法不能被重写</li></ul><h3 id="2-2-static"><a href="#2-2-static" class="headerlink" title="2.2 static"></a>2.2 static</h3><ul><li><strong>修饰类的话只能修饰内部类:</strong>, 非静态内部类编译完成之后会隐含一个引用,指向创建他的外围类,但是静态内部类没有. <strong>所以,静态内部类的创建不需要依赖外围类,不能使用任何外围类的非static成员变量和方法</strong></li><li><strong>修饰成员变量和成员方法:</strong>: 被类中所有的对象共享,存放在JVM方法区(1.8为Metaspace),类加载后可直接调用,aclass.staticMethod(),aclass.staticValue</li><li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li></ul><p>单例模式:</p><pre><code>class Singleton&#123;    private volatile static Singleton uniqueInstance;    private Sigleton()&#123;&#125;;    public static Singleton getSingleton()&#123;        if(uniqueInstance==null)&#123;        synchronized(Singleton.class)&#123;        if(uniqueInstance==null)&#123;            uniqueInstance = new Singleton();            &#125;                &#125;            &#125;    return uniqueInstance;        &#125;&#125;</code></pre><h3 id="2-3-super关键字"><a href="#2-3-super关键字" class="headerlink" title="2.3 super关键字"></a>2.3 super关键字</h3><p>用于子类从父类访问变量和方法</p><pre><code>class Animal&#123;    String color = &quot;white&quot;;&#125;class Dog extends Animal&#123;    String color = &quot;black&quot;;    void printColor()&#123;    System.out.println(color); //打印狗的color    System.out.println(super.color);//打印Animal 的color    &#125;&#125;</code></pre><h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3.面向对象"></a>3.面向对象</h2><h3 id="3-1-三大特性"><a href="#3-1-三大特性" class="headerlink" title="3.1 三大特性"></a>3.1 三大特性</h3><ul><li><strong>封装:</strong> 指把对象的属性封装在对象内部,不允许外部对象直接访问对象的内部信息</li></ul><ol><li>把对象属性私有化,对每个属性提供getter,setter方法</li><li>如果有带参的构造函数,需要再写一个不带参的构造函数</li><li>建议重写toString方法</li><li>内部细节对外部调用透明,外部调用无需修改或者关心内部实现</li></ol><ul><li><strong>继承:</strong> 是使用已存在的类的定义作为基础建立新类的技术,新类的定义可以增加新的属性或新的方法,可以使用父类的功能,不能选择性继承.<br>通过继承,可以提高代码的复用率,提高开发效率.</li></ul><ol><li>子类拥有父类的属性和方法,但是私有方法和属性无法访问,只能拥有.</li><li>子类可以拥有自己的方法,在父类的基础上拓展.</li><li>可以用自己的方法实现父类的方法?</li></ol><ul><li><strong>多态:</strong> 指一个对象拥有多种状态. 具体表现为父类的引用指向子类的实例.</li></ul><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><pre><code>abstract class Animal&#123;    abstract void eat();&#125;class Cat extends Animal&#123;    public void eat()&#123; System.out.println(&quot;eat fish&quot;);&#125;&#125;class Dog extends Animal&#123;    public void eat()&#123;System.out.println(&quot;eat bones&quot;);&#125;&#125;class DuoTaiDemo&#123;    public static void main(String[] args)&#123;    function(new Cat());    function(new Dog());        Animal a = new Cat();    a.eat();    Cat c = (Cat)a;    c.eat();&#125;    public static void function(Animal a)&#123;    a.eat();    if(a instanceof Cat)&#123;Cat c = (Cat)a;c.catchMouse();&#125;    else if(a instanceof Dog)&#123;Dog c = (Dog)a;c.kanJia();&#125;    &#125;&#125;</code></pre><h3 id="3-2-重载和重写"><a href="#3-2-重载和重写" class="headerlink" title="3.2 重载和重写"></a>3.2 重载和重写</h3><p><strong>重载:</strong> 发生在同一个类中,方法名必须相同,参数类型不同,个数不同,顺序不同,方法返回值和访问修饰符可以不同.比如多个构造器.<br><strong>重写:</strong> 发生在运行期,子类对父类允许访问的方法进行重新编写.</p><ol><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><pre><code>public class Hero &#123;    public String name() &#123;        return &quot;超级英雄&quot;;    &#125;&#125;public class SuperMan extends Hero&#123;    @Override    public String name() &#123;        return &quot;超人&quot;;    &#125;    public Hero hero() &#123;        return new Hero();    &#125;&#125;public class SuperSuperMan extends SuperMan &#123;    public String name() &#123;        return &quot;超级超级英雄&quot;;    &#125;    @Override    public SuperMan hero() &#123;        return new SuperMan();    &#125;&#125;</code></pre><h3 id="3-3-泛型"><a href="#3-3-泛型" class="headerlink" title="3.3 泛型"></a>3.3 泛型</h3><p>泛型提供了编译时类型安全检测机制. 本质是参数化类型,也就是说操作的数据类型被指定为一个参数.<br>类型擦除: 在编译期间,所有的泛型信息都会被擦掉.</p><ul><li>泛型方法</li></ul><pre><code>public static &lt;E&gt; void printArray(E() inputArray)&#123;    for(E element: inputArray)&#123;    System.out.println(&quot;%s&quot;,element);    &#125;&#125; //传入不同类型数组: Interger,Double 和 Charcter // 打印不同数组</code></pre><ul><li>泛型类</li></ul><pre><code>public class Generic&lt;T&gt;&#123;    private T key;    public Generic(T key)&#123;    this.key = key;    &#125;    public T getKey()&#123;return key;&#125;&#125;Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</code></pre><ul><li>泛型接口</li></ul><pre><code>public interface Generic&lt;T&gt;&#123; public T method();&#125;//实现泛型接口，不指定类型：class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;&#123;    @Override    public T method() &#123;        return null;    &#125;&#125;Copy to clipboardErrorCopied//实现泛型接口，指定类型：class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;&#123;    @Override    public String method() &#123;        return &quot;hello&quot;;    &#125;&#125;</code></pre><p>常用的通配符为： T，E，K，V，？</p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h3 id="3-4-接口和抽象类"><a href="#3-4-接口和抽象类" class="headerlink" title="3.4 接口和抽象类"></a>3.4 接口和抽象类</h3><ul><li>接口<ul><li>接口是抽象类的延伸</li><li>从Java8开始,可以拥有默认的方法实现</li><li>接口的字段+方法默认都是public的,且不允许定义为private或protected</li><li>接口的字段默认都是static 和 final的</li></ul></li></ul><pre><code>public class Main &#123;    public static void main(String[] args) &#123;        Person p = new Student(&quot;Xiao Ming&quot;);        p.run();    &#125;&#125;interface Person &#123;    String getName();    default void run() &#123;        System.out.println(getName() + &quot; run&quot;);    &#125;&#125;class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return this.name;    &#125;&#125;//Xiao ming run</code></pre><ul><li>抽象类<ul><li>如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</li><li>抽象类和抽象方法都使用 abstract 关键字进行声明</li></ul></li></ul><p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p><p><strong>比较</strong></p><ul><li>抽象类的目的是实现代码复用,一种模板设计的方法,可以让这些类都派生于一个抽象类。</li><li>接口的设计目的是对类的行为进行约束,提供一种机制,使不同的类可以继承相同的功能。</li><li>接口的字段只能是static 和final,抽象类的字段没有这些要求。</li><li>接口的成员只能是public,抽象类可以有不同的访问权限。</li></ul><h3 id="3-5-反射"><a href="#3-5-反射" class="headerlink" title="3.5 反射"></a>3.5 反射</h3><ul><li>JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息。</li><li>通过Class实例获取 class信息的方法成为反射。</li></ul><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><ul><li>当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</li><li>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。</li><li>也可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</li></ul><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li>Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。</li></ul><pre><code>通过反射创建对象Class clazz = Class.forName(&quot;reflection.Person&quot;);//获取 Person 类的 Class 对象Person p = (Person)class.newInstance();//使用.newInstane 方法创建对象Constructor c = class.getDeclaredConstructor(String.class,String.class,int.class);//获取构造方法并创建对象Person p1 = (Person)c.newInstance(&quot;李四&quot;,&quot;男&quot;,&quot;20&quot;);//创建对象并设置属性</code></pre><h2 id="4-Java8新特性"><a href="#4-Java8新特性" class="headerlink" title="4.Java8新特性"></a>4.Java8新特性</h2><h3 id="4-1-streams（流）"><a href="#4-1-streams（流）" class="headerlink" title="4.1 streams（流）"></a>4.1 streams（流）</h3><ul><li><strong>Fliter</strong></li></ul><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p><pre><code>stringList    .stream()    .filter((s)-&gt;s.startsWith(&quot;a&quot;))    .forEach(System.out::println);</code></pre><ul><li><strong>Sorted</strong></li></ul><pre><code>stringList    .stream()    .sorted()    .filter((s)-&gt;s.startsWith(&quot;a&quot;))    .forEach(System.out::println);</code></pre><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：</p><ul><li><strong>Map</strong></li></ul><p>中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。<br>下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p><pre><code>stringList    .stream()    .map(String::toUpperCase)    .sorted((a,b)-&gt;b.compareTo(a))    .forEach(System.out::println);</code></pre><ul><li><strong>Match</strong></li></ul><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 最终操作 ，并返回一个 boolean 类型的值。</p><pre><code>// 测试 Match (匹配)操作        boolean anyStartsWithA =                stringList                        .stream()                        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));        System.out.println(anyStartsWithA);      // true        boolean allStartsWithA =                stringList                        .stream()                        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));        System.out.println(allStartsWithA);      // false        boolean noneStartsWithZ =                stringList                        .stream()                        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));        System.out.println(noneStartsWithZ);      // true</code></pre><ul><li><strong>Count</strong></li></ul><p>计数是一个 最终操作，返回Stream中元素的个数，返回值类型是 long。</p><pre><code>//测试 Count (计数)操作long startsWithB =stringList          .stream()          .filter((s) -&gt; s.startsWith(&quot;b&quot;))          .count();System.out.println(startsWithB);    // 3</code></pre><ul><li>Reduce(规约)</li></ul><p>这是一个 最终操作 ，允许通过指定的函数来将stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：</p><pre><code>//测试 Reduce (规约)操作        Optional&lt;String&gt; reduced =                stringList                        .stream()                        .sorted()                        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);        reduced.ifPresent(System.out::println);//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2</code></pre><p>译者注： 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于Integer sum = integers.reduce(0, (a, b) -&gt; a+b);也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><pre><code>// 字符串连接，concat = &quot;ABCD&quot;String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); // 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = &quot;ace&quot;concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;). filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0). reduce(&quot;&quot;, String::concat);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专项练习（三）（depth&amp;height）</title>
      <link href="/2021/03/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%88depth-height%EF%BC%89/"/>
      <url>/2021/03/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%88depth-height%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a><br>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>输出：true</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">recur</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>recur<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">if</span> right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> abs<span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a><br>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>输出：<span class="token number">2</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token comment" spellcheck="true"># class Solution:</span><span class="token comment" spellcheck="true">#     def minDepth(self, root: TreeNode) -> int:</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        que <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> que<span class="token punctuation">:</span>            node<span class="token punctuation">,</span> depth <span class="token operator">=</span> que<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> node<span class="token punctuation">.</span>left <span class="token operator">and</span> <span class="token operator">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                <span class="token keyword">return</span> depth            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                que<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                que<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token number">0</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a><br>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">给定二叉树 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>，    <span class="token number">3</span>   <span class="token operator">/</span> \  <span class="token number">9</span>  <span class="token number">20</span>    <span class="token operator">/</span>  \   <span class="token number">15</span>   <span class="token number">7</span>返回它的最大深度 <span class="token number">3</span> 。</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>left <span class="token operator">and</span> <span class="token operator">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        max_depth <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>left<span class="token punctuation">:</span>            max_depth <span class="token operator">=</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> max_depth<span class="token punctuation">)</span>        <span class="token keyword">if</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            max_depth <span class="token operator">=</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> max_depth<span class="token punctuation">)</span>                <span class="token keyword">return</span> max_depth <span class="token operator">+</span> <span class="token number">1</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a><br>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。<br>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>输出：<span class="token number">6</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">return</span> left<span class="token operator">+</span>right<span class="token operator">+</span><span class="token number">1</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a><br>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>解释<span class="token punctuation">:</span>   <span class="token number">1</span>            <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">/</span>   \<span class="token number">2</span>     <span class="token number">3</span>         <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> \     \  <span class="token number">5</span>     <span class="token number">4</span>       <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>                rightmost_value_at_depth <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 深度为索引，存放节点的值</span>        max_depth <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            node<span class="token punctuation">,</span> depth <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 维护二叉树的最大深度</span>                max_depth <span class="token operator">=</span> max<span class="token punctuation">(</span>max_depth<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 如果不存在对应深度的节点我们才插入</span>                rightmost_value_at_depth<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>depth<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>rightmost_value_at_depth<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token keyword">for</span> depth <span class="token keyword">in</span> range<span class="token punctuation">(</span>max_depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专项练习（二）（构建树）</title>
      <link href="/2021/03/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%88%E6%9E%84%E5%BB%BA%E6%A0%91%EF%BC%89/"/>
      <url>/2021/03/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%88%E6%9E%84%E5%BB%BA%E6%A0%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008. 前序遍历构造二叉搜索树</a><br>返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。</li></ul><p>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）</p><p>题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bstFromPreorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>lower <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> upper <span class="token operator">=</span> float…            <span class="token keyword">return</span> root                idx <span class="token operator">=</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span>        <span class="token keyword">return</span> helper<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a><br>根据一棵树的前序遍历与中序遍历构造二叉树。</li></ul><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder</p><pre class=" language-python"><code class="language-python">前序遍历 preorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>中序遍历 inorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>返回如下的二叉树：    <span class="token number">3</span>   <span class="token operator">/</span> \  <span class="token number">9</span>  <span class="token number">20</span>    <span class="token operator">/</span>  \   <span class="token number">15</span>   <span class="token number">7</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> preorder <span class="token operator">or</span> <span class="token operator">not</span> inorder<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#根节点为前序遍历第一个节点</span>        index <span class="token operator">=</span> inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 定位出中序遍历根节点的索引</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># 递归构建左子树，前序遍历左子树范围为，1~index,中序遍历左子树范围为0~index-1</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 递归构建右子树，前序遍历右子树范围为index之后，中序遍历右子树范围为index往后</span>        <span class="token keyword">return</span> root</code></pre><ul><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a><br>根据一棵树的中序遍历与后序遍历构造二叉树。</li></ul><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><pre class=" language-python"><code class="language-python">中序遍历 inorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>后序遍历 postorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>返回如下的二叉树：    <span class="token number">3</span>   <span class="token operator">/</span> \  <span class="token number">9</span>  <span class="token number">20</span>    <span class="token operator">/</span>  \   <span class="token number">15</span>   <span class="token number">7</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> inorder <span class="token operator">or</span> <span class="token operator">not</span> postorder<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        index <span class="token operator">=</span> inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>postorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>buildTree<span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>postorder<span class="token punctuation">[</span>index<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root</code></pre><ul><li><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a><br>返回与给定的前序和后序遍历匹配的任何二叉树。</p><p>pre 和 post 遍历中的值是不同的正整数。</p></li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：pre <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> post <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token number">1</span> <span class="token operator">&lt;=</span> pre<span class="token punctuation">.</span>length <span class="token operator">==</span> post<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">30</span>pre<span class="token punctuation">[</span><span class="token punctuation">]</span> 和 post<span class="token punctuation">[</span><span class="token punctuation">]</span> 都是 <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> pre<span class="token punctuation">.</span>length 的排列每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">constructFromPrePost</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pre<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> post<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> pre <span class="token operator">or</span> <span class="token operator">not</span> post<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>pre<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> root        index <span class="token operator">=</span> post<span class="token punctuation">.</span>index<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 后序遍历右子树起始位置</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>constructFromPrePost<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>post<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>constructFromPrePost<span class="token punctuation">(</span>pre<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>post<span class="token punctuation">[</span>index<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root</code></pre><ul><li><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a><br>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</li></ul><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>解释：<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span> 也将被视为正确答案：</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span>         mid <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">//</span><span class="token number">2</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>        left <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span>        right <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>sortedArrayToBST<span class="token punctuation">(</span>left<span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>sortedArrayToBST<span class="token punctuation">(</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> root</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 二叉数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树专项练习（一）（遍历思想）</title>
      <link href="/2021/03/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/03/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a><br>给定一个 N 叉树，返回其节点值的 前序遍历 。</li></ul><p>N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p><p>进阶：</p><p>递归法很简单，你可以使用迭代法完成此题吗?<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">"""# Definition for a Node.class Node:    def __init__(self, val=None, children=None):        self.val = val        self.children = children"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>                    helper<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a><br>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a><br>给定一个二叉树，返回它的 后序 遍历。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>     <span class="token number">1</span>    \     <span class="token number">2</span>    <span class="token operator">/</span>   <span class="token number">3</span> 输出<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><p>+<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a><br>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">二叉树：<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">3</span>   <span class="token operator">/</span> \  <span class="token number">9</span>  <span class="token number">20</span>    <span class="token operator">/</span>  \   <span class="token number">15</span>   <span class="token number">7</span>返回其层序遍历结果：<span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>…        helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a><br>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</li></ul><pre class=" language-python"><code class="language-python">例如：给定二叉树 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">3</span>   <span class="token operator">/</span> \  <span class="token number">9</span>  <span class="token number">20</span>    <span class="token operator">/</span>  \   <span class="token number">15</span>   <span class="token number">7</span>返回其自底向上的层序遍历为：<span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, left=None, right=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.left = left</span><span class="token comment" spellcheck="true">#         self.right = right</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrderBottom</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>…        helper<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表专项练习（二）</title>
      <link href="/2021/02/21/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/02/21/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li>[83.删除排序链表中的重复元素] (<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a>)<br>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span>输出<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        sen <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        sen<span class="token punctuation">.</span>next <span class="token operator">=</span> head        pre<span class="token punctuation">,</span>cur <span class="token operator">=</span> sen<span class="token punctuation">,</span>head        rep <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>val <span class="token keyword">in</span> rep<span class="token punctuation">:</span>                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                rep<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> sen<span class="token punctuation">.</span>next</code></pre><ul><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82.删除排序链表中的重复元素</a><br>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span>输出<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token operator">==</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head        slow <span class="token operator">=</span> dummy        fast <span class="token operator">=</span> dummy<span class="token punctuation">.</span>next        <span class="token keyword">while</span> fast<span class="token punctuation">:</span>            <span class="token keyword">while</span> fast<span class="token punctuation">.</span>next <span class="token operator">and</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next            <span class="token keyword">if</span> slow<span class="token punctuation">.</span>next <span class="token operator">==</span> fast<span class="token punctuation">:</span>                slow <span class="token operator">=</span> fast            <span class="token keyword">else</span><span class="token punctuation">:</span>                slow<span class="token punctuation">.</span>next <span class="token operator">=</span> fast<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next</code></pre><ul><li><a href="https://www.realestate.com.au/property-house-vic-melbourne-129654678">21.合并两个有序链表</a></li></ul><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：l1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> l1<span class="token punctuation">:</span>            <span class="token keyword">return</span> l2        <span class="token keyword">elif</span> <span class="token operator">not</span> l2<span class="token punctuation">:</span>            <span class="token keyword">return</span> l1        <span class="token keyword">if</span> l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            l1<span class="token punctuation">.</span>next <span class="token operator">=</span>  self<span class="token punctuation">.</span>mergeTwoLists<span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span>l2<span class="token punctuation">)</span>            <span class="token keyword">return</span> l1        <span class="token keyword">elif</span> l1<span class="token punctuation">.</span>val<span class="token operator">>=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            l2<span class="token punctuation">.</span>next <span class="token operator">=</span>  self<span class="token punctuation">.</span>mergeTwoLists<span class="token punctuation">(</span>l2<span class="token punctuation">.</span>next<span class="token punctuation">,</span>l1<span class="token punctuation">)</span>            <span class="token keyword">return</span> l2</code></pre><ul><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141.环形链表</a><br>给定一个链表，判断链表中是否有环。</li></ul><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">1</span>输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head <span class="token operator">or</span> <span class="token operator">not</span> head<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next        slow <span class="token operator">=</span> head        <span class="token keyword">while</span> slow<span class="token operator">!=</span>fast<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> fast <span class="token operator">or</span> <span class="token operator">not</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">True</span></code></pre><p>+<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142.环形链表 II</a><br>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O(1) 空间解决此题？</p><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">1</span>输出：返回索引为 <span class="token number">1</span> 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        fast<span class="token punctuation">,</span>slow <span class="token operator">=</span> head<span class="token punctuation">,</span>head        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>…            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表专项练习（一）</title>
      <link href="/2021/02/11/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/02/11/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206.反转链表</a><br>反转一个单链表。</li></ul><p><strong>示例:</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>NULL输出<span class="token punctuation">:</span> <span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span>NULL</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span>            <span class="token keyword">return</span>        pre <span class="token operator">=</span> None        cur <span class="token operator">=</span> head                <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre            pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> tmp        <span class="token keyword">return</span> pre</code></pre><p>+<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92.反转链表 II</a><br>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。<br><strong>示例:</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>NULL<span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">4</span>输出<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>NULL</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> left<span class="token punctuation">:</span> int<span class="token punctuation">,</span> right<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        dummy_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy_node<span class="token punctuation">.</span>next <span class="token operator">=</span> head        pre <span class="token operator">=</span> dummy_node        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next        cur <span class="token operator">=</span> pre<span class="token punctuation">.</span>next        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">:</span>            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next            next<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> next        <span class="token keyword">return</span> dummy_node<span class="token punctuation">.</span>next</code></pre><ul><li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328.奇偶链表</a><br>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</li></ul><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br><strong>示例:</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>NULL输出<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span>NULL</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span>            <span class="token keyword">return</span>        even<span class="token punctuation">,</span>odd <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head        evenhead <span class="token operator">=</span> head<span class="token punctuation">.</span>next        <span class="token keyword">while</span> even <span class="token operator">and</span> even<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            odd<span class="token punctuation">.</span>next <span class="token operator">=</span> even<span class="token punctuation">.</span>next            odd <span class="token operator">=</span> odd<span class="token punctuation">.</span>next            even<span class="token punctuation">.</span>next <span class="token operator">=</span> odd<span class="token punctuation">.</span>next            even <span class="token operator">=</span> even<span class="token punctuation">.</span>next        odd<span class="token punctuation">.</span>next <span class="token operator">=</span> evenhead        <span class="token keyword">return</span> head</code></pre><p>+[86.分隔链表] (<a href="https://leetcode-cn.com/problems/partition-list/">https://leetcode-cn.com/problems/partition-list/</a>)<br>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><p><strong>示例:</strong></p><pre class=" language-python"><code class="language-python">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token number">3</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> head<span class="token punctuation">:</span>            <span class="token keyword">return</span>        large <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        small <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cur <span class="token operator">=</span> head        largeCur <span class="token operator">=</span> large        smallCur <span class="token operator">=</span> small        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>val <span class="token operator">>=</span> x<span class="token punctuation">:</span>                largeCur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next                largeCur <span class="token operator">=</span> largeCur<span class="token punctuation">.</span>next                largeCur<span class="token punctuation">.</span>next <span class="token operator">=</span> None            <span class="token keyword">else</span><span class="token punctuation">:</span>                smallCur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next                smallCur <span class="token operator">=</span> smallCur<span class="token punctuation">.</span>next                smallCur<span class="token punctuation">.</span>next <span class="token operator">=</span> None        smallCur<span class="token punctuation">.</span>next <span class="token operator">=</span> large<span class="token punctuation">.</span>next        <span class="token keyword">return</span> small<span class="token punctuation">.</span>next</code></pre><p>+<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203.移除链表元素</a><br>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。<br><strong>示例</strong>:</p><pre class=" language-python"><code class="language-python">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> val <span class="token operator">=</span> <span class="token number">6</span>输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, val=0, next=None):</span><span class="token comment" spellcheck="true">#         self.val = val</span><span class="token comment" spellcheck="true">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        sen <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        sen<span class="token punctuation">.</span>next <span class="token operator">=</span> head        pre<span class="token punctuation">,</span>cur <span class="token operator">=</span> sen<span class="token punctuation">,</span>head        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">:</span>                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> sen<span class="token punctuation">.</span>next</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划专项练习（二）</title>
      <link href="/2021/02/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/02/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>打开题目-&gt;思索半天-&gt;打开题解-&gt;思索一会-&gt;妙不可言-&gt;我是废物</strong><br>+<a href="https://leetcode-cn.com/problems/house-robber/">198.打家劫舍</a><br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>输出：<span class="token number">4</span>解释：偷窃 <span class="token number">1</span> 号房屋 <span class="token punctuation">(</span>金额 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> ，然后偷窃 <span class="token number">3</span> 号房屋 <span class="token punctuation">(</span>金额 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>。     偷窃到的最高金额 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">4</span> 。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>n<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>+<a href="https://leetcode-cn.com/problems/house-robber-ii/">213.打家劫舍②</a><br>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>输出：<span class="token number">3</span>解释：你不能先偷窃 <span class="token number">1</span> 号房屋（金额 <span class="token operator">=</span> <span class="token number">2</span>），然后偷窃 <span class="token number">3</span> 号房屋（金额 <span class="token operator">=</span> <span class="token number">2</span>）<span class="token punctuation">,</span> 因为他们是相邻的。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rob</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token operator">==</span>None <span class="token operator">or</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        dp1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dp2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dp1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        dp1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        dp2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        dp2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            dp2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>max<span class="token punctuation">(</span>dp2<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp2<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>+<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416.分割等和子集</a><br>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><p>每个数组中的元素不会超过 100<br>数组的大小不会超过 200<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> true解释<span class="token punctuation">:</span> 数组可以分割成 <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span> 和 <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">.</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canPartition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> n<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        target <span class="token operator">=</span> sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">if</span> sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        maxnum <span class="token operator">=</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> maxnum <span class="token operator">></span> target<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> j <span class="token operator">>=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span></code></pre><p>+<a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474.一和零</a><br>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：strs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"10"</span><span class="token punctuation">,</span> <span class="token string">"0001"</span><span class="token punctuation">,</span> <span class="token string">"111001"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">3</span>输出：<span class="token number">4</span>解释：最多有 <span class="token number">5</span> 个 <span class="token number">0</span> 和 <span class="token number">3</span> 个 <span class="token number">1</span> 的最大子集是 <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"10","0001","1","0"&amp;#125; ，因此答案是 4 。</span>其他满足题意但较小的子集包括 <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"0001","1"&amp;#125; 和 &amp;#123;"10","1","0"&amp;#125; 。&amp;#123;"111001"&amp;#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span></code></pre><pre class=" language-python"><code class="language-python">        <span class="token keyword">if</span> len<span class="token punctuation">(</span>strs<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> strs_item <span class="token keyword">in</span> strs<span class="token punctuation">:</span>            zeros <span class="token operator">=</span> strs_item<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span>            ones <span class="token operator">=</span> strs_item<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">,</span> zeros <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">,</span> ones <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span> zeros<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>ones<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">978.最长湍流子数组</a><br>当 A 的子数组 A[i], A[i+1], …, A[j] 满足下列条件时，我们称其为湍流子数组：</li></ul><p>若 i &lt;= k &lt; j，当 k 为奇数时， A[k] &gt; A[k+1]，且当 k 为偶数时，A[k] &lt; A[k+1]；<br>或 若 i &lt;= k &lt; j，当 k 为偶数时，A[k] &gt; A[k+1] ，且当 k 为奇数时， A[k] &lt; A[k+1]。<br>也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。</p><p>返回 A 的最大湍流子数组的长度。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>输出：<span class="token number">5</span>解释：<span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> A<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> A<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxTurbulenceSize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        up <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>n        down <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>n        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                down<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> up<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span> arr<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                up<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> down<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span>max<span class="token punctuation">(</span>down<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><p>+<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96.不同的二叉搜索数</a><br>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">3</span>输出<span class="token punctuation">:</span> <span class="token number">5</span>解释<span class="token punctuation">:</span>给定 n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> 一共有 <span class="token number">5</span> 种不同结构的二叉搜索树<span class="token punctuation">:</span>   <span class="token number">1</span>         <span class="token number">3</span>     <span class="token number">3</span>      <span class="token number">2</span>      <span class="token number">1</span>    \       <span class="token operator">/</span>     <span class="token operator">/</span>      <span class="token operator">/</span> \      \     <span class="token number">3</span>     <span class="token number">2</span>     <span class="token number">1</span>      <span class="token number">1</span>   <span class="token number">3</span>      <span class="token number">2</span>    <span class="token operator">/</span>     <span class="token operator">/</span>       \                 \   <span class="token number">2</span>     <span class="token number">1</span>         <span class="token number">2</span>                 <span class="token number">3</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numTrees</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># g(n) = f(1)+f(2)+...+f(n)</span>        <span class="token comment" spellcheck="true"># f(i) = g(i-1)*g(n-i) </span>        <span class="token comment" spellcheck="true"># f(5) = g(5-1)*g(5-5)</span>        <span class="token comment" spellcheck="true">#      = g(4)*g(0)</span>        <span class="token comment" spellcheck="true">#      = </span>        <span class="token comment" spellcheck="true"># g(n) = g(n-1)*g(0) + g(n-2)*g(1)+...g(n-i)*g(i-1)</span>        g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>g<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>             g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> g<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token operator">*</span>g<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> g<span class="token punctuation">[</span>n<span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划专项练习（一）</title>
      <link href="/2021/02/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/02/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>下面是「动态规划』问题的思考路径，供大家参考。<br><img src="/image/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png"></p><p>转载自：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p><ul><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5.最长回文子串</a><br>给你一个字符串 s，找到 s 中最长的回文子串。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：s <span class="token operator">=</span> <span class="token string">"babad"</span>输出：<span class="token string">"bab"</span>解释：<span class="token string">"aba"</span> 同样是符合题意的答案。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span><span class="token operator">*</span>n <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        ans <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">for</span> l <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> i<span class="token operator">+</span>l                <span class="token keyword">if</span> j<span class="token operator">>=</span>n<span class="token punctuation">:</span>                    <span class="token keyword">break</span>                <span class="token keyword">if</span> l <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                <span class="token keyword">elif</span> l <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">and</span> l<span class="token operator">+</span><span class="token number">1</span><span class="token operator">></span>len<span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">:</span>                    ans <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">:</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> ans</code></pre><ul><li><a href="https://leetcode-cn.com/problems/maximum-subarray/">53.最大子序和</a><br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出：<span class="token number">6</span>解释：连续子数组 <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> 的和最大，为 <span class="token number">6</span> 。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        cur <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                        cur <span class="token operator">=</span> max<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>cur<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span>cur<span class="token punctuation">)</span>                    <span class="token keyword">return</span> res</code></pre><ul><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152.乘机最大子数组</a><br>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> <span class="token number">6</span>解释<span class="token punctuation">:</span> 子数组 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> 有最大乘积 <span class="token number">6</span>。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span> <span class="token keyword">return</span>         res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        pre_max <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        pre_min <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            cur_max <span class="token operator">=</span> max<span class="token punctuation">(</span>pre_max <span class="token operator">*</span> num<span class="token punctuation">,</span> pre_min <span class="token operator">*</span> num<span class="token punctuation">,</span> num<span class="token punctuation">)</span>            cur_min <span class="token operator">=</span> min<span class="token punctuation">(</span>pre_max <span class="token operator">*</span> num<span class="token punctuation">,</span> pre_min <span class="token operator">*</span> num<span class="token punctuation">,</span> num<span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> cur_max<span class="token punctuation">)</span>            pre_max <span class="token operator">=</span> cur_max            pre_min <span class="token operator">=</span> cur_min        <span class="token keyword">return</span> res</code></pre><ul><li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300.最长递增子序列</a><br>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</li></ul><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">]</span>输出：<span class="token number">4</span>解释：最长递增子序列是 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">101</span><span class="token punctuation">]</span>，因此长度为 <span class="token number">4</span> 。</code></pre><pre class=" language-python"><code class="language-python">       <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span></code></pre><ul><li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143.最长公共子序列</a><br>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</li></ul><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：text1 <span class="token operator">=</span> <span class="token string">"abcde"</span><span class="token punctuation">,</span> text2 <span class="token operator">=</span> <span class="token string">"ace"</span> 输出：<span class="token number">3</span>  解释：最长公共子序列是 <span class="token string">"ace"</span>，它的长度为 <span class="token number">3</span>。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> text2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span>m <span class="token operator">=</span> len<span class="token punctuation">(</span>text1<span class="token punctuation">)</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>text2<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> text1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode股票问题DP解法</title>
      <link href="/2021/02/01/leetcode%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98DP%E8%A7%A3%E6%B3%95/"/>
      <url>/2021/02/01/leetcode%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98DP%E8%A7%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>力扣的股票问题一共有6道：</p><ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></li></ul><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>动态规划并不是这些问题的唯一解也不是最优解，但是相比于dp，其他解法并未建立起问题之间的联系，有些解法则难以理解。下面根据题目的难度以及条件的复杂度顺序给出dp题解，层层跟进，易于理解。</p><p><strong>+ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></strong><br>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出：<span class="token number">5</span>解释：在第 <span class="token number">2</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">1</span>）的时候买入，在第 <span class="token number">5</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">6</span>）的时候卖出，最大利润 <span class="token operator">=</span> <span class="token number">6</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">5</span> 。     注意利润不能是 <span class="token number">7</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>           <span class="token comment" spellcheck="true"># 构建2维的dp数组</span>        <span class="token comment" spellcheck="true"># dp[i][0] 为第i天不持股的利润</span>        <span class="token comment" spellcheck="true"># dp[i][1] 为第i天持股的利润</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 特殊情况，在第一天购入股票的利润</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">#第i天不持股的利润为前一天不持股状态的利润和昨天持股今天卖出的利润之间的最大值</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#第i天持股的利润为前一天持股状态的利润和今天买入的利润之间的最大值</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><p><strong>+ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></strong></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> <span class="token number">7</span>解释<span class="token punctuation">:</span> 在第 <span class="token number">2</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">1</span>）的时候买入，在第 <span class="token number">3</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">5</span>）的时候卖出<span class="token punctuation">,</span> 这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">5</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">4</span> 。     随后，在第 <span class="token number">4</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">3</span>）的时候买入，在第 <span class="token number">5</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">6</span>）的时候卖出<span class="token punctuation">,</span> 这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">6</span><span class="token operator">-</span><span class="token number">3</span> <span class="token operator">=</span> <span class="token number">3</span> 。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> prices<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                 <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#第i天不持股的利润为前一天不持股状态的利润和昨天持股今天卖出的利润之间的最大值</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">#第i天持股的利润为前一天持股状态的利润和昨天不持股今天买入的利润之间的最大值</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><strong>+ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></strong><br>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> prices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fee <span class="token operator">=</span> <span class="token number">2</span>输出<span class="token punctuation">:</span> <span class="token number">8</span>解释<span class="token punctuation">:</span> 能够达到的最大利润<span class="token punctuation">:</span>  在此处买入 prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>在此处卖出 prices<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">8</span>在此处买入 prices<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>在此处卖出 prices<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span>总利润<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">9</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">.</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span>fee<span class="token punctuation">:</span>int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> prices<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>fee        <span class="token comment" spellcheck="true">#相比与上一题在买入时多增加了一个手续费而已</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#第i天不持股的利润为前一天不持股状态的利润和昨天持股今天卖出的利润之间的最大值</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>fee<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">#第i天持股的利润为前一天持股状态的利润和昨天不持股今天买入的利润之间的最大值</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><p><strong>+ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></strong><br>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> <span class="token number">3</span> 解释<span class="token punctuation">:</span> 对应的交易状态为<span class="token punctuation">:</span> <span class="token punctuation">[</span>买入<span class="token punctuation">,</span> 卖出<span class="token punctuation">,</span> 冷冻期<span class="token punctuation">,</span> 买入<span class="token punctuation">,</span> 卖出<span class="token punctuation">]</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> prices<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#相比于122，增加了第三条状态</span>        <span class="token comment" spellcheck="true"># dp[i][0]: 手上不持有股票，并且处于冷冻期中的累计最大收益</span>        <span class="token comment" spellcheck="true"># dp[i][1]: 手上持有股票的最大收益</span>        <span class="token comment" spellcheck="true"># dp[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#处于冷冻期，必定是前一天做出了卖出的操作</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#持有股票，可能是前一天持有，也可能是在非冷冻期进行了买入操作</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#可能前一天是冷冻期，也可能前一天是非冷冻期，不可能在前一天进行卖出的操作</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><strong>+ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></strong><br>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><strong>示例</strong></p><pre class=" language-python"><code class="language-python">输入：prices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>输出：<span class="token number">6</span>解释：在第 <span class="token number">4</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">0</span>）的时候买入，在第 <span class="token number">6</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">3</span>）的时候卖出，这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">3</span><span class="token operator">-</span><span class="token number">0</span> <span class="token operator">=</span> <span class="token number">3</span> 。     随后，在第 <span class="token number">7</span> 天（股票价格 <span class="token operator">=</span> <span class="token number">1</span>）的时候买入，在第 <span class="token number">8</span> 天 （股票价格 <span class="token operator">=</span> <span class="token number">4</span>）的时候卖出，这笔交易所能获得利润 <span class="token operator">=</span> <span class="token number">4</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3</span> 。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#相比于122，增加了第三个状态</span>        <span class="token comment" spellcheck="true"># dp[i][0][k]: 手上不持有股票，并且已经交易k次的最大收益</span>        <span class="token comment" spellcheck="true"># dp[i][1][k]: 手上持有股票，并且已经交易k次的最大收益</span>        <span class="token comment" spellcheck="true"># 此时k取值为0,1,2</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer12-13</title>
      <link href="/2020/11/10/%E5%89%91%E6%8C%87offer12-13/"/>
      <url>/2020/11/10/%E5%89%91%E6%8C%87offer12-13/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span><span class="token string">"ABCESFCSADEE"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">"ABCCED"</span>输出<span class="token punctuation">:</span>true</code></pre><p>###题解:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasPath</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> matrix<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> <span class="token operator">not</span> path<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        x <span class="token operator">=</span> <span class="token punctuation">[</span>list<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>cols<span class="token operator">*</span>i<span class="token punctuation">:</span>cols<span class="token operator">*</span>i<span class="token operator">+</span>cols<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rows<span class="token punctuation">)</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">#构建二维数组</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rows<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>cols<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>x<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>matrix<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#如果找到路径开头字母</span>            <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>           <span class="token comment" spellcheck="true">#并且后面不为空，开始递归</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>                  matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span>       <span class="token comment" spellcheck="true">#将路径已经遍历过的路径设为空，避免'SAS'这种情况</span>            <span class="token keyword">if</span> i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true">#左</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#右</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> j<span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token number">-1</span><span class="token punctuation">,</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token comment" spellcheck="true"># 上    </span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#下</span>                <span class="token keyword">return</span> <span class="token boolean">True</span><span class="token comment" spellcheck="true">#             return True</span>            matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>     <span class="token comment" spellcheck="true">#如果四个方位都没找到路径,将矩阵元素设为初始值</span><span class="token comment" spellcheck="true">#             return False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span>输出<span class="token punctuation">:</span><span class="token number">21</span></code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">cal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        sum <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> temp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            sum <span class="token operator">+=</span>temp<span class="token operator">%</span><span class="token number">10</span>            temp <span class="token operator">=</span> temp<span class="token operator">/</span><span class="token number">10</span>        <span class="token keyword">return</span> sum    <span class="token keyword">def</span> <span class="token function">movingCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> threshold<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">:</span>        num <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rows<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>cols<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>cal<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>cal<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">&lt;=</span>threshold<span class="token punctuation">)</span><span class="token punctuation">:</span>                    num <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">elif</span> <span class="token punctuation">(</span>rows <span class="token operator">==</span><span class="token number">1</span> <span class="token operator">or</span> cols <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> num        <span class="token keyword">return</span> num</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>life&#39;s an open door</title>
      <link href="/2020/10/23/life-s-an-open-door/"/>
      <url>/2020/10/23/life-s-an-open-door/</url>
      
        <content type="html"><![CDATA[<h2 id="Open-Door"><a href="#Open-Door" class="headerlink" title="Open Door"></a>Open Door</h2><p>I’ve seen mountains<br>I’ve seen breaches<br>Distant seas<br>Uncharted beaches<br>I’ve seen light<br>From many welcome ports<br><img src="/image/22.jpg"><br>I’ve been warmed on<br>Tropic islands<br>Lost in city’s<br>Sounds and slience<br>I’ve been found<br>On many golden shores<br><img src="/image/1.jpg"></p><p>I’ve lived the stories<br>Heartbreaks and glories<br>The happiness and the strife<br>The tears and the laughter<br>Of a life<br><img src="/image/2.jpg"></p><p>Lately I dreamed<br>I’ve tasted<br>All life’s treasures<br>But still my heart fills me<br>With pleasures</p><p>This life’s an open door</p><p><img src="/image/3.jpg"></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2923703&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 杂事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-有效的数独(medium)</title>
      <link href="/2020/09/25/leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-medium/"/>
      <url>/2020/09/25/leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-medium/</url>
      
        <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description"></a>Problem description</h3><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>1.数字 1-9 在每一行只能出现一次。<br>2.数字 1-9 在每一列只能出现一次。<br>3.数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p>示例1：</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">"5"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"5"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"4"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"5"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> true</code></pre><p>示例2：</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"5"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"4"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"5"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"9"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> false</code></pre><p>解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。<br>说明:</p><p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>给定数独序列只包含数字 1-9 和字符 ‘.’ 。<br>给定数独永远是 9x9 形式的。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>3个维度的字典：行，列，块。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">)</span><span class="token punctuation">:</span>        rows <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125; for i in range(9)]</span>        columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125; for i in range(9)]</span>        boxs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125; for i in range(9)]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                num <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">if</span> num <span class="token operator">!=</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    num <span class="token operator">=</span> int<span class="token punctuation">(</span>num<span class="token punctuation">)</span>                    boxIndex <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">//</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> j <span class="token operator">//</span> <span class="token number">3</span>                    rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                    columns<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span>columns<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                    boxs<span class="token punctuation">[</span>boxIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span>boxs<span class="token punctuation">[</span>boxIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                    <span class="token keyword">if</span> rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">or</span> columns<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">or</span> boxs<span class="token punctuation">[</span>boxIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信条中的钳形行动</title>
      <link href="/2020/09/12/%E4%BF%A1%E6%9D%A1%E4%B8%AD%E7%9A%84%E9%92%B3%E5%BD%A2%E8%A1%8C%E5%8A%A8/"/>
      <url>/2020/09/12/%E4%BF%A1%E6%9D%A1%E4%B8%AD%E7%9A%84%E9%92%B3%E5%BD%A2%E8%A1%8C%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>电影的信息量实在太大，对影片的一些想法和理解是出了影院才想通的。信条中的钳形行动非常有趣，也是理解影片的一个比较大的难点，在这里记录一下自己的理解和想法。</p><h3 id="时间流"><a href="#时间流" class="headerlink" title="时间流"></a>时间流</h3><p>虽然说影片里的人和物品时间倒退是基于物理中的熵增熵减，但是个人觉得用时间流来解释更方便理解。</p><p>如下图所示，对于两边的世界来说，时间流的正向都是从左到右的。而当人穿过装置时，就可以获得逆行于时间流的能力。也就是说在正常人的世界里，人可以先看到和感知14:00的时间和事件，后面才可以感受到15:00的时间和事件。而对逆行者，先看到和感知的是15:00的时间，当他一步步前进时，看到的是倒退的世界。如果正常人看逆行者，则会看到倒退一系列古怪的行为。<br><img src="/image/4.jpg"></p><h3 id="钳形行动"><a href="#钳形行动" class="headerlink" title="钳形行动"></a>钳形行动</h3><p>简单来说就是现在的自己，和在未来穿越到过去，也就是现在的自己，双方合作的行为。在萨托的行动中，未来的自己通过无线电给现在的发送信息，获得的信息只需要通过倒放即可还原。也可以说，行动开始前，行动的结果已经确定了。然而现在的人，仍然需要通过装置回到过去，以形成闭环。<br><img src="/image/6.jpg"></p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ol><li>钳形行动的第一个人 ，会不会没有未来的自己来提示？<br>时间可能没有起点和终点，就和数字没有最大和最小一样，总会有一个未来的自己在你更前面。</li><li>弹孔是什么时候存在的?<br>其实不难理解，比如逆行者在14：00 打下了弹孔，继续逆行，那么在14：00 之前，比如说13:30会有人发现它，并将其修复，那么在13:30之前弹孔都不会存在。而在13:30之后，越来越接近14:00，弹孔会慢慢出现，并在子弹收回的时候彻底消失。对于正常世界的人，永远看不到弹孔的形成。</li><li>为什么进入装置的时候会有时候看到两个人，有时候会消失？<br>看到两人的情况为左半部分，逆行者比如在14:00进入装置，14:00之后会回到正常状态，与时间流同向，所以就会有一个14:00-14:30的正向自己，和14:30-14:00的逆向自己，而对其他人来说，就会看到装置里冲出一个正常人，和一个在14:00-14:30倒退的人。<br>消失的情况为右半部分，如果在15:00通过装置并回到了过去，在其他人看来，会有一个14:30-15:00的倒退人和一个正常人同时进入装置并消失。因为正常人的时间流继续经过了15:00并且无法观测到过去。<br><img src="/image/5.jpg"></li><li>未来的人能对过去的人进行干扰吗？<br>是可以的，只不过对现在的你来说，干扰已经完成，只不过现在的你还需要做同一份动作。还可以做这么一种假设，时光机已经发明过了，世界已经被修改了无数次，由于世界的规律是由波动趋于平稳，无数次的危机也许就像影片里的一样，不过是某个无关紧要的小爆炸罢了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂事 </tag>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无题</title>
      <link href="/2020/09/01/%E6%97%A0%E9%A2%98/"/>
      <url>/2020/09/01/%E6%97%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="美好的回忆，似乎也可以变成梦魇"><a href="#美好的回忆，似乎也可以变成梦魇" class="headerlink" title="美好的回忆，似乎也可以变成梦魇"></a>美好的回忆，似乎也可以变成梦魇</h4><p><img src="/image/EIYG5432.JPG"></p>]]></content>
      
      
      <categories>
          
          <category> 杂事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素贝叶斯分类器（numpy实现）</title>
      <link href="/2020/05/10/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
      <url>/2020/05/10/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 只考虑离散值</span><span class="token keyword">class</span> <span class="token class-name">NaiveBayesClassifier</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>n_classes<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>n_classes<span class="token operator">=</span>n_classes        self<span class="token punctuation">.</span>priori_P<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>        self<span class="token punctuation">.</span>conditional_P<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>        self<span class="token punctuation">.</span>N<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>X<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 公式 7.19</span>            self<span class="token punctuation">.</span>priori_P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>y<span class="token punctuation">[</span>y<span class="token operator">==</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">)</span>        <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>N<span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span>len<span class="token punctuation">(</span>np<span class="token punctuation">.</span>unique<span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>conditional_P<span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>            <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                val<span class="token operator">=</span>X<span class="token punctuation">[</span>row<span class="token punctuation">,</span>col<span class="token punctuation">]</span>                <span class="token keyword">if</span> val <span class="token operator">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>conditional_P<span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>conditional_P<span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>val<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>                    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">)</span><span class="token punctuation">:</span>                        D_xi<span class="token operator">=</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>col<span class="token punctuation">]</span><span class="token operator">==</span>val<span class="token punctuation">)</span>                        D_c<span class="token operator">=</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>y<span class="token operator">==</span>i<span class="token punctuation">)</span>                        D_cxi<span class="token operator">=</span>len<span class="token punctuation">(</span>np<span class="token punctuation">.</span>intersect1d<span class="token punctuation">(</span>D_xi<span class="token punctuation">,</span>D_c<span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true"># 公式 7.20</span>                        self<span class="token punctuation">.</span>conditional_P<span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>val<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>D_cxi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>y<span class="token punctuation">[</span>y<span class="token operator">==</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>N<span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>    <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span>        pred_y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>self<span class="token punctuation">.</span>priori_P<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                val<span class="token operator">=</span>X<span class="token punctuation">[</span>i<span class="token punctuation">,</span>col<span class="token punctuation">]</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">)</span><span class="token punctuation">:</span>                    p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*=</span>self<span class="token punctuation">.</span>conditional_P<span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">[</span>val<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            pred_y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>pred_y<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 连续值</span><span class="token keyword">class</span> <span class="token class-name">NaiveBayesClassifierContinuous</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>n_classes<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>n_classes<span class="token operator">=</span>n_classes        self<span class="token punctuation">.</span>priori_P<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>    <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>X<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>mus<span class="token operator">=</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">,</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>sigmas<span class="token operator">=</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">,</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 公式 7.19</span>            self<span class="token punctuation">.</span>priori_P<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>y<span class="token punctuation">[</span>y<span class="token operator">==</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>            X_c<span class="token operator">=</span>X<span class="token punctuation">[</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>y<span class="token operator">==</span>c<span class="token punctuation">)</span><span class="token punctuation">]</span>            self<span class="token punctuation">.</span>mus<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">=</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>X_c<span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>sigmas<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">=</span>np<span class="token punctuation">.</span>std<span class="token punctuation">(</span>X_c<span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span>        pred_y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_classes<span class="token punctuation">)</span><span class="token punctuation">:</span>                p<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">=</span>self<span class="token punctuation">.</span>priori_P<span class="token punctuation">[</span>c<span class="token punctuation">]</span>                <span class="token keyword">for</span> col <span class="token keyword">in</span> range<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    x<span class="token operator">=</span>X<span class="token punctuation">[</span>i<span class="token punctuation">,</span>col<span class="token punctuation">]</span>                    p<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">*=</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token operator">/</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>np<span class="token punctuation">.</span>pi<span class="token punctuation">)</span><span class="token operator">*</span>self<span class="token punctuation">.</span>sigmas<span class="token punctuation">[</span>c<span class="token punctuation">,</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span>np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">(</span>x<span class="token operator">-</span>self<span class="token punctuation">.</span>mus<span class="token punctuation">[</span>c<span class="token punctuation">,</span>col<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>self<span class="token punctuation">.</span>sigmas<span class="token punctuation">[</span>c<span class="token punctuation">,</span>col<span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            pred_y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>pred_y<span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    X <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    X_test<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>                     <span class="token punctuation">]</span><span class="token punctuation">)</span>    naive_bayes<span class="token operator">=</span>NaiveBayesClassifier<span class="token punctuation">(</span>n_classes<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>    naive_bayes<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span>y<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'self.PrirP:'</span><span class="token punctuation">,</span>naive_bayes<span class="token punctuation">.</span>priori_P<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'self.CondiP:'</span><span class="token punctuation">,</span>naive_bayes<span class="token punctuation">.</span>conditional_P<span class="token punctuation">)</span>    pred_y<span class="token operator">=</span>naive_bayes<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_test<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'pred_y:'</span><span class="token punctuation">,</span>pred_y<span class="token punctuation">)</span></code></pre><p><img src="/image/22.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法，机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序python实现</title>
      <link href="/2020/04/30/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fpython%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/04/30/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fpython%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> arr  <span class="token keyword">else</span><span class="token punctuation">:</span>    curr <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                                     <span class="token comment" spellcheck="true">## 基准值</span>    less <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i <span class="token operator">&lt;=</span> curr<span class="token punctuation">]</span>          <span class="token comment" spellcheck="true">## 小于基准值的元素放入less数组</span>    greater <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">></span>curr<span class="token punctuation">]</span>         <span class="token comment" spellcheck="true">## 大于基准值的元素放入greater数组</span>    <span class="token keyword">return</span> quicksort<span class="token punctuation">(</span>less<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token operator">+</span>quicksort<span class="token punctuation">(</span>greater<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">## 递归处理大小两个数组 并返回最终排序好的数组</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环神经网络基础</title>
      <link href="/2020/04/27/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/04/27/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><h2 id="1-循环神经网络的介绍"><a href="#1-循环神经网络的介绍" class="headerlink" title="1. 循环神经网络的介绍"></a>1. 循环神经网络的介绍</h2><p>在普通的神经网络中，信息的传递是单向的，这种限制虽然使得网络变得更容易学习，但在一定程度上也减弱了神经网络模型的能力。特别是在很多现实任务中，网络的输出不仅和当前时刻的输入相关，也和其过去一段时间的输出相关。此外，普通网络难以处理时序数据，比如视频、语音、文本等，时序数据的长度一般是不固定的，而前馈神经网络要求输入和输出的维数都是固定的，不能任意改变。因此，当处理这一类和时序相关的问题时，就需要一种能力更强的模型。</p><p>循环神经网络（Recurrent Neural Network，RNN）是一类具有短期记忆能力的神经网络。在循环神经网络中，神经元不但可以接受其它神经元的信息，也可以接受自身的信息，形成具有环路的网络结构。换句话说：神经元的输出可以在下一个时间步直接作用到自身（</p><p>入）</p><p><img src="/image/1.3/RNN%E5%9B%BE.png"></p><p>通过简化图，看到RNN比传统的神经网络多了一个循环圈，这个循环表示的就是在下一个时间步（<strong>Time Step</strong>）上会返回作为输入的一部分，把RNN在时间点上展开，得到的图形如下：</p><p><img src="/image/1.3/RNN%E5%B1%95%E5%BC%80.png"></p><p>或者是：</p><p><img src="/image/1.3/%E5%9F%BA%E7%A1%80%E7%9A%84RNN%E5%B1%95%E5%BC%80%E5%9B%BE.png"></p><p>在不同的时间步，RNN的输入都将与之前的时间状态有关，$t_n$时刻网络的输出结果是该时刻的输入和所有历史共同作用的结果，这就达到了对时间序列建模的目的。</p><p>RNN的不同表示和功能可以通过下图看出：</p><p><img src="/image/1.3/RNN%E5%8A%9F%E8%83%BD.png"></p><ul><li>图1：固定长度的输入和输出 (e.g. 图像分类)</li><li>图2：序列输出 (e.g.图像转文字)</li><li>图3：数列输入 (e.g. 文本分类)</li><li>图4：异步的序列输入和输出(e.g.文本翻译).</li><li>图5：同步的序列输入和输出 (e.g. 根据视频的每一帧来对视频进行分类)</li></ul><h2 id="2-LSTM和GRU"><a href="#2-LSTM和GRU" class="headerlink" title="2. LSTM和GRU"></a>2. LSTM和GRU</h2><h3 id="2-1-LSTM的基础介绍"><a href="#2-1-LSTM的基础介绍" class="headerlink" title="2.1 LSTM的基础介绍"></a>2.1 LSTM的基础介绍</h3><p>假如现在有这样一个需求，根据现有文本预测下一个词语，比如<code>天上的云朵漂浮在__</code>，通过间隔不远的位置就可以预测出来词语是<code>天上</code>，但是对于其他一些句子，可能需要被预测的词语在前100个词语之前，那么此时由于间隔非常大，随着间隔的增加可能会导致真实的预测值对结果的影响变的非常小，而无法非常好的进行预测（RNN中的长期依赖问题（long-Term Dependencies））</p><p>那么为了解决这个问题需要<strong>LSTM</strong>（<strong>Long Short-Term Memory网络</strong>）</p><p>LSTM是一种RNN特殊的类型，可以学习长期依赖信息。在很多问题上，LSTM都取得相当巨大的成功，并得到了广泛的应用。</p><p>一个LSMT的单元就是下图中的一个绿色方框中的内容：</p><p><img src="/image/1.3/LSTM1.jpg"></p><p>其中$\sigma$表示sigmod函数，其他符号的含义：</p><p><img src="/image/1.3/LSTM2.jpg"></p><h3 id="2-2-LSTM的核心"><a href="#2-2-LSTM的核心" class="headerlink" title="2.2 LSTM的核心"></a>2.2 LSTM的核心</h3><p><img src="/image/1.3/LSTM3.png"></p><p>LSTM的核心在于单元（细胞）中的状态，也就是上图中最上面的那根线。</p><p>但是如果只有上面那一条线，那么没有办法实现信息的增加或者删除，所以在LSTM是通过一个叫做<code>门</code>的结构实现，门可以选择让信息通过或者不通过。</p><p>这个门主要是通过sigmoid和点乘（<code>pointwise multiplication</code>）实现的</p><p><img src="/image/1.3/LSTM4.png"></p><p>我们都知道，$sigmoid$的取值范围是在(0,1)之间，如果接近0表示不让任何信息通过，如果接近1表示所有的信息都会通过</p><h3 id="2-3-逐步理解LSTM"><a href="#2-3-逐步理解LSTM" class="headerlink" title="2.3 逐步理解LSTM"></a>2.3 逐步理解LSTM</h3><h4 id="2-3-1-遗忘门"><a href="#2-3-1-遗忘门" class="headerlink" title="2.3.1 遗忘门"></a>2.3.1 遗忘门</h4><p>遗忘门通过sigmoid函数来决定哪些信息会被遗忘</p><p>在下图就是$h_{t-1}和x_t$进行合并（concat）之后乘上权重和偏置，通过sigmoid函数，输出0-1之间的一个值，这个值会和前一次的细胞状态($C_{t-1}​$)进行点乘，从而决定遗忘或者保留</p><p><img src="/image/1.3/%E6%98%93%E7%8E%8B%E9%97%A8.png"></p><h4 id="2-3-2-输入门"><a href="#2-3-2-输入门" class="headerlink" title="2.3.2 输入门"></a>2.3.2 输入门</h4><p><img src="/image/1.3/%E8%BE%93%E5%85%A5%E9%97%A8.png"></p><p>下一步就是决定哪些新的信息会被保留，这个过程有两步：</p><ol><li>一个被称为<code>输入门</code>的sigmoid 层决定哪些信息会被更新</li><li><code>tanh</code>会创造一个新的候选向量$\widetilde{C}_{t}$，后续可能会被添加到细胞状态中</li></ol><p>例如：</p><p><code>我昨天吃了苹果，今天我想吃菠萝</code>，在这个句子中，通过遗忘门可以遗忘<code>苹果</code>,同时更新新的主语为<code>菠萝</code></p><p>现在就可以更新旧的细胞状态$C_{t-1}$为新的$C_{ t }​$ 了。</p><p>更新的构成很简单就是：</p><ol><li>旧的细胞状态和遗忘门的结果相乘</li><li>然后加上 输入门和tanh相乘的结果</li></ol><p><img src="/image/1.3/LSTM-update.png"></p><h4 id="2-3-3-输出门"><a href="#2-3-3-输出门" class="headerlink" title="2.3.3 输出门"></a>2.3.3 输出门</h4><p>最后，我们需要决定什么信息会被输出，也是一样这个输出经过变换之后会通过sigmoid函数的结果来决定那些细胞状态会被输出。</p><p><img src="/image/1.3/%E8%BE%93%E5%87%BA%E9%97%A8.png"></p><p>步骤如下：</p><ol><li>前一次的输出和当前时间步的输入的组合结果通过sigmoid函数进行处理得到$O_t$</li><li>更新后的细胞状态$C_t$会经过tanh层的处理，把数据转化到(-1,1)的区间</li><li>tanh处理后的结果和$O_t$进行相乘，把结果输出同时传到下一个LSTM的单元</li></ol><h3 id="2-4-GRU，LSTM的变形"><a href="#2-4-GRU，LSTM的变形" class="headerlink" title="2.4 GRU，LSTM的变形"></a>2.4 GRU，LSTM的变形</h3><p>GRU(Gated Recurrent Unit),是一种LSTM的变形版本， 它将遗忘和输入门组合成一个“更新门”。它还合并了单元状态和隐藏状态，并进行了一些其他更改，由于他的模型比标准LSTM模型简单，所以越来越受欢迎。</p><p><img src="/image/1.3/GRU.png"></p><p>LSTM内容参考地址：<a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">https://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p><h2 id="3-双向LSTM"><a href="#3-双向LSTM" class="headerlink" title="3. 双向LSTM"></a>3. 双向LSTM</h2><p>单向的 RNN，是根据前面的信息推出后面的，但有时候只看前面的词是不够的， 可能需要预测的词语和后面的内容也相关，那么此时需要一种机制，能够让模型不仅能够从前往后的具有记忆，还需要从后往前需要记忆。此时双向LSTM就可以帮助我们解决这个问题</p><p><img src="/image/1.3/bidir_lstm.png"></p><p>由于是双向LSTM，所以每个方向的LSTM都会有一个输出，最终的输出会有2部分，所以往往需要concat的操作</p>]]></content>
      
      
      <categories>
          
          <category> nlp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nlp </tag>
            
            <tag> rnn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降优化算法</title>
      <link href="/2020/04/25/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/25/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的优化算法介绍"><a href="#常见的优化算法介绍" class="headerlink" title="常见的优化算法介绍"></a>常见的优化算法介绍</h2><h3 id="1-梯度下降算法（batch-gradient-descent-BGD）"><a href="#1-梯度下降算法（batch-gradient-descent-BGD）" class="headerlink" title="1. 梯度下降算法（batch gradient descent BGD）"></a>1. 梯度下降算法（batch gradient descent BGD）</h3><p>每次迭代都需要把所有样本都送入，这样的好处是每次迭代都顾及了全部的样本，做的是全局最优化,但是有可能达到局部最优。</p><h3 id="2-随机梯度下降法-Stochastic-gradient-descent-SGD"><a href="#2-随机梯度下降法-Stochastic-gradient-descent-SGD" class="headerlink" title="2. 随机梯度下降法 (Stochastic gradient descent SGD)"></a>2. 随机梯度下降法 (Stochastic gradient descent SGD)</h3><p>针对梯度下降算法训练速度过慢的缺点，提出了随机梯度下降算法，随机梯度下降算法算法是从样本中随机抽出一组，训练后按梯度更新一次，然后再抽取一组，再更新一次，在样本量及其大的情况下，可能不用训练完所有的样本就可以获得一个损失值在可接受范围之内的模型了。</p><p>torch中的api为：<code>torch.optim.SGD()</code></p><h3 id="3-小批量梯度下降-Mini-batch-gradient-descent-MBGD）"><a href="#3-小批量梯度下降-Mini-batch-gradient-descent-MBGD）" class="headerlink" title="3. 小批量梯度下降 (Mini-batch gradient descent MBGD）"></a>3. 小批量梯度下降 (Mini-batch gradient descent MBGD）</h3><p>SGD相对来说要快很多，但是也有存在问题，由于单个样本的训练可能会带来很多噪声，使得SGD并不是每次迭代都向着整体最优化方向，因此在刚开始训练时可能收敛得很快，但是训练一段时间后就会变得很慢。在此基础上又提出了小批量梯度下降法，它是每次从样本中随机抽取一小批进行训练，而不是一组，这样即保证了效果又保证的速度。</p><h3 id="4-动量法"><a href="#4-动量法" class="headerlink" title="4. 动量法"></a>4. 动量法</h3><p>mini-batch SGD算法虽然这种算法能够带来很好的训练速度，但是在到达最优点的时候并不能够总是真正到达最优点，而是在最优点附近徘徊。</p><p>另一个缺点就是mini-batch SGD需要我们挑选一个合适的学习率，当我们采用小的学习率的时候，会导致网络在训练的时候收敛太慢；当我们采用大的学习率的时候，会导致在训练过程中优化的幅度跳过函数的范围，也就是可能跳过最优点。我们所希望的仅仅是网络在优化的时候网络的损失函数有一个很好的收敛速度同时又不至于摆动幅度太大。</p><p>所以Momentum优化器刚好可以解决我们所面临的问题，它主要是基于梯度的移动指数加权平均，对网络的梯度进行平滑处理的，让梯度的摆动幅度变得更小。<br>$$<br>\begin{align*}<br>&amp;gradent = 0.8\nabla w + 0.2 history_gradent  &amp;，\nabla w 表示当前一次的梯度<br>&amp;w = w - \alpha* gradent &amp;，\alpha表示学习率<br>\end{align*}<br>$$</p><p>（注：t+1的的histroy_gradent 为第t次的gradent）</p><h3 id="5-AdaGrad"><a href="#5-AdaGrad" class="headerlink" title="5. AdaGrad"></a>5. AdaGrad</h3><p>AdaGrad算法就是将每一个参数的每一次迭代的梯度取平方累加后在开方，用全局学习率除以这个数，作为学习率的动态更新，从而达到<strong>自适应学习率</strong>的效果<br>$$<br>\begin{align*}<br>&amp;gradent = history_gradent + (\nabla w)^2 \<br>&amp;w = w - \frac{\alpha}{\sqrt{gradent}+\delta} \nabla w ,&amp;\delta为小常数，为了数值稳定大约设置为10^{-7}<br>\end{align*}<br>$$</p><h3 id="6-RMSProp"><a href="#6-RMSProp" class="headerlink" title="6. RMSProp"></a>6. RMSProp</h3><p>Momentum优化算法中，虽然初步解决了优化中摆动幅度大的问题,为了进一步优化损失函数在更新中存在摆动幅度过大的问题，并且进一步加快函数的收敛速度，RMSProp算法对参数的梯度使用了平方加权平均数。<br><img src="/image/1.2/1.png"></p><h3 id="7-Adam"><a href="#7-Adam" class="headerlink" title="7. Adam"></a>7. Adam</h3><p>Adam（Adaptive Moment Estimation）算法是将Momentum算法和RMSProp算法结合起来使用的一种算法,能够达到防止梯度的摆幅多大，同时还能够加开收敛速度<br><img src="/image/1.2/2.png"></p><p>torch中的api为：<code>torch.optim.Adam()</code></p><h3 id="8-效果演示："><a href="#8-效果演示：" class="headerlink" title="8. 效果演示："></a>8. 效果演示：</h3><p><img src="/image/1.2/%E4%BC%98%E5%8C%96%E5%99%A8%E6%96%B9%E6%B3%95.gif"></p>]]></content>
      
      
      <categories>
          
          <category> nlp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nlp </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-最长公共前缀(easy)</title>
      <link href="/2020/04/23/leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-easy/"/>
      <url>/2020/04/23/leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-easy/</url>
      
        <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description"></a>Problem description</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"flower"</span><span class="token punctuation">,</span><span class="token string">"flow"</span><span class="token punctuation">,</span><span class="token string">"flight"</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> <span class="token string">"fl"</span></code></pre><p>示例 2:</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"dog"</span><span class="token punctuation">,</span><span class="token string">"racecar"</span><span class="token punctuation">,</span><span class="token string">"car"</span><span class="token punctuation">]</span>输出<span class="token punctuation">:</span> <span class="token string">""</span>解释<span class="token punctuation">:</span> 输入不存在公共前缀。</code></pre><p>说明:<br>所有输入只包含小写字母 a-z 。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>将list第一个词的第一个字符储存在pre里面<br>从list内每个词的第一个字母开始，如果字符相同，则pre中替换到词中的下一个字符继续进行对比。<br>如果字符不同，则返回索引i前的字符。<br>如果都相同，则返回第一个词的全部。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        count <span class="token operator">=</span> len<span class="token punctuation">(</span>strs<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>            pre <span class="token operator">=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">if</span> any<span class="token punctuation">(</span>i <span class="token operator">==</span> len<span class="token punctuation">(</span>strs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> strs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> pre <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span>                    <span class="token keyword">return</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch的tensor操作</title>
      <link href="/2020/04/23/pytorch%E7%9A%84tensor%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/23/pytorch%E7%9A%84tensor%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch的tensor使用"><a href="#Pytorch的tensor使用" class="headerlink" title="Pytorch的tensor使用"></a>Pytorch的tensor使用</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>张量和Pytorch中的张量</li><li>pytorch中如何创建张量</li><li>pytorch中tensor的常见方法</li><li>pytorch中tensor的数据类型</li><li>pytorch中如何实现tensor在cpu和cuda中转化</li></ol><h2 id="1-张量Tensor"><a href="#1-张量Tensor" class="headerlink" title="1. 张量Tensor"></a>1. 张量Tensor</h2><p>张量是一个统称，其中包含很多类型：</p><ol><li>0阶张量：标量、常数，0-D Tensor</li><li>1阶张量：向量，1-D Tensor</li><li>2阶张量：矩阵，2-D Tensor</li><li>3阶张量</li><li>…</li><li>N阶张量</li></ol><h2 id="2-Pytorch中创建张量"><a href="#2-Pytorch中创建张量" class="headerlink" title="2. Pytorch中创建张量"></a>2. Pytorch中创建张量</h2><ol><li><p>使用python中的列表或者序列创建tensor</p><pre class=" language-python"><code class="language-python">torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1.0000</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0000</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">1.0000</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0000</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p>使用numpy中的数组创建tensor</p><pre class=" language-python"><code class="language-python">torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token number">5</span><span class="token punctuation">,</span>  <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p>使用torch的api创建tensor</p><ol><li><p><code>torch.empty(3,4)</code>创建3行4列的空的tensor，会用无用数据进行填充</p></li><li><p><code>torch.ones([3,4])</code> 创建3行4列的<strong>全为1</strong>的tensor</p></li><li><p><code>torch.zeros([3,4])</code>创建3行4列的<strong>全为0</strong>的tensor</p></li><li><p><code>torch.rand([3,4])</code> 创建3行4列的<strong>随机值</strong>的tensor，随机值的区间是<code>[0, 1)</code></p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.8237</span><span class="token punctuation">,</span>  <span class="token number">0.5781</span><span class="token punctuation">,</span>  <span class="token number">0.6879</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span> <span class="token number">0.3816</span><span class="token punctuation">,</span>  <span class="token number">0.7249</span><span class="token punctuation">,</span>  <span class="token number">0.0998</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p><code>torch.randint(low=0,high=10,size=[3,4])</code> 创建3行4列的<strong>随机整数</strong>的tensor，随机值的区间是<code>[low, high)</code></p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> torch<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p><code>torch.randn([3,4])</code> 创建3行4列的<strong>随机数</strong>的tensor，随机值的分布式均值为0，方差为1</p></li></ol></li></ol><h2 id="3-Pytorch中tensor的常用方法"><a href="#3-Pytorch中tensor的常用方法" class="headerlink" title="3. Pytorch中tensor的常用方法"></a>3. Pytorch中tensor的常用方法</h2><ol><li><p>获取tensor中的数据(当tensor中只有一个元素可用)：<code>tensor.item()</code></p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> aOut<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">:</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">0</span></code></pre></li><li><p>转化为numpy数组</p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">]</span><span class="token punctuation">:</span> z<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">]</span><span class="token punctuation">:</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2.5871205</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">7.3690367</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2.4918075</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>float32<span class="token punctuation">)</span></code></pre></li><li><p>获取形状：<code>tensor.size()</code></p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">72</span><span class="token punctuation">]</span><span class="token punctuation">:</span> xOut<span class="token punctuation">[</span><span class="token number">72</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>    <span class="token number">1</span><span class="token punctuation">,</span>     <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span>    <span class="token number">3</span><span class="token punctuation">,</span>     <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span>    <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>int32<span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">73</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">73</span><span class="token punctuation">]</span><span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p>形状改变：<code>tensor.view((3,4))</code>。类似numpy中的reshape，是一种浅拷贝，仅仅是形状发生改变</p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">76</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">76</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>    <span class="token number">1</span><span class="token punctuation">,</span>     <span class="token number">2</span><span class="token punctuation">,</span>     <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span>    <span class="token number">4</span><span class="token punctuation">,</span>     <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>int32<span class="token punctuation">)</span></code></pre></li><li><p>获取阶数：<code>tensor.dim()</code></p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>dim<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">2</span></code></pre></li><li><p>获取最大值：<code>tensor.max()</code></p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">78</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>max<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">78</span><span class="token punctuation">]</span><span class="token punctuation">:</span> tensor<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>int32<span class="token punctuation">)</span></code></pre></li><li><p>转置：<code>tensor.t()</code></p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">79</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>t<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">79</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>    <span class="token number">1</span><span class="token punctuation">,</span>     <span class="token number">3</span><span class="token punctuation">,</span>     <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span>    <span class="token number">2</span><span class="token punctuation">,</span>     <span class="token number">4</span><span class="token punctuation">,</span>       <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>int32<span class="token punctuation">)</span></code></pre></li><li><p><code>tensor[1,3]</code>  获取tensor中第一行第三列的值</p></li><li><p><code>tensor[1,3]=100</code> 对tensor中第一行第三列的位置进行赋值100</p></li><li><p>tensor的切片</p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">:</span> xOut<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.6437</span><span class="token punctuation">,</span> <span class="token number">1.9439</span><span class="token punctuation">,</span> <span class="token number">1.5393</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">1.3491</span><span class="token punctuation">,</span> <span class="token number">1.9575</span><span class="token punctuation">,</span> <span class="token number">1.0552</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">1.5106</span><span class="token punctuation">,</span> <span class="token number">1.0123</span><span class="token punctuation">,</span> <span class="token number">1.0961</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">1.4382</span><span class="token punctuation">,</span> <span class="token number">1.5939</span><span class="token punctuation">,</span> <span class="token number">1.5012</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">1.5267</span><span class="token punctuation">,</span> <span class="token number">1.4858</span><span class="token punctuation">,</span> <span class="token number">1.4007</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">102</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>Out<span class="token punctuation">[</span><span class="token number">102</span><span class="token punctuation">]</span><span class="token punctuation">:</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.9439</span><span class="token punctuation">,</span> <span class="token number">1.9575</span><span class="token punctuation">,</span> <span class="token number">1.0123</span><span class="token punctuation">,</span> <span class="token number">1.5939</span><span class="token punctuation">,</span> <span class="token number">1.4858</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li></ol><p>​    </p><h2 id="4-tensor的数据类型"><a href="#4-tensor的数据类型" class="headerlink" title="4. tensor的数据类型"></a>4. tensor的数据类型</h2><p>tensor中的数据类型非常多，常见类型如下：</p><p><img src="/image/1.2/tensor%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><p>上图中的Tensor types表示这种type的tensor是其实例</p><ol><li><p>获取tensor的数据类型:<code>tensor.dtype</code></p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>dtypeOut<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">:</span> torch<span class="token punctuation">.</span>int32</code></pre></li><li><p>创建数据的时候指定类型</p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">88</span><span class="token punctuation">]</span><span class="token punctuation">:</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">88</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">9.1167e+18</span><span class="token punctuation">,</span> <span class="token number">0.0000e+00</span><span class="token punctuation">,</span> <span class="token number">7.8796e+15</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">8.3097e-43</span><span class="token punctuation">,</span> <span class="token number">0.0000e+00</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.0000e+00</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p>类型的修改</p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">:</span> aOut<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">:</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>int32<span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a<span class="token punctuation">.</span>type<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>float<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">:</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">:</span> a<span class="token punctuation">.</span>double<span class="token punctuation">(</span><span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">:</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float64<span class="token punctuation">)</span></code></pre></li></ol><h2 id="5-tensor的其他操作"><a href="#5-tensor的其他操作" class="headerlink" title="5. tensor的其他操作"></a>5. tensor的其他操作</h2><ol><li><p>tensor和tensor相加</p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">94</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>new_ones<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float<span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">95</span><span class="token punctuation">]</span><span class="token punctuation">:</span> y <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">96</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token operator">+</span>yOut<span class="token punctuation">[</span><span class="token number">96</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.6437</span><span class="token punctuation">,</span> <span class="token number">1.9439</span><span class="token punctuation">,</span> <span class="token number">1.5393</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.3491</span><span class="token punctuation">,</span> <span class="token number">1.9575</span><span class="token punctuation">,</span> <span class="token number">1.0552</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.5106</span><span class="token punctuation">,</span> <span class="token number">1.0123</span><span class="token punctuation">,</span> <span class="token number">1.0961</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.4382</span><span class="token punctuation">,</span> <span class="token number">1.5939</span><span class="token punctuation">,</span> <span class="token number">1.5012</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.5267</span><span class="token punctuation">,</span> <span class="token number">1.4858</span><span class="token punctuation">,</span> <span class="token number">1.4007</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">98</span><span class="token punctuation">]</span><span class="token punctuation">:</span> torch<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">98</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.6437</span><span class="token punctuation">,</span> <span class="token number">1.9439</span><span class="token punctuation">,</span> <span class="token number">1.5393</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.3491</span><span class="token punctuation">,</span> <span class="token number">1.9575</span><span class="token punctuation">,</span> <span class="token number">1.0552</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.5106</span><span class="token punctuation">,</span> <span class="token number">1.0123</span><span class="token punctuation">,</span> <span class="token number">1.0961</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.4382</span><span class="token punctuation">,</span> <span class="token number">1.5939</span><span class="token punctuation">,</span> <span class="token number">1.5012</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.5267</span><span class="token punctuation">,</span> <span class="token number">1.4858</span><span class="token punctuation">,</span> <span class="token number">1.4007</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>add<span class="token punctuation">(</span>y<span class="token punctuation">)</span>Out<span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.6437</span><span class="token punctuation">,</span> <span class="token number">1.9439</span><span class="token punctuation">,</span> <span class="token number">1.5393</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.3491</span><span class="token punctuation">,</span> <span class="token number">1.9575</span><span class="token punctuation">,</span> <span class="token number">1.0552</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.5106</span><span class="token punctuation">,</span> <span class="token number">1.0123</span><span class="token punctuation">,</span> <span class="token number">1.0961</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.4382</span><span class="token punctuation">,</span> <span class="token number">1.5939</span><span class="token punctuation">,</span> <span class="token number">1.5012</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.5267</span><span class="token punctuation">,</span> <span class="token number">1.4858</span><span class="token punctuation">,</span> <span class="token number">1.4007</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x<span class="token punctuation">.</span>add_<span class="token punctuation">(</span>y<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#带下划线的方法会对x进行就地修改</span>Out<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.6437</span><span class="token punctuation">,</span> <span class="token number">1.9439</span><span class="token punctuation">,</span> <span class="token number">1.5393</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.3491</span><span class="token punctuation">,</span> <span class="token number">1.9575</span><span class="token punctuation">,</span> <span class="token number">1.0552</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.5106</span><span class="token punctuation">,</span> <span class="token number">1.0123</span><span class="token punctuation">,</span> <span class="token number">1.0961</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.4382</span><span class="token punctuation">,</span> <span class="token number">1.5939</span><span class="token punctuation">,</span> <span class="token number">1.5012</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.5267</span><span class="token punctuation">,</span> <span class="token number">1.4858</span><span class="token punctuation">,</span> <span class="token number">1.4007</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token comment" spellcheck="true">#x发生改变</span>Out<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.6437</span><span class="token punctuation">,</span> <span class="token number">1.9439</span><span class="token punctuation">,</span> <span class="token number">1.5393</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.3491</span><span class="token punctuation">,</span> <span class="token number">1.9575</span><span class="token punctuation">,</span> <span class="token number">1.0552</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.5106</span><span class="token punctuation">,</span> <span class="token number">1.0123</span><span class="token punctuation">,</span> <span class="token number">1.0961</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.4382</span><span class="token punctuation">,</span> <span class="token number">1.5939</span><span class="token punctuation">,</span> <span class="token number">1.5012</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">1.5267</span><span class="token punctuation">,</span> <span class="token number">1.4858</span><span class="token punctuation">,</span> <span class="token number">1.4007</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>注意：带下划线的方法（比如:<code>add_</code>)会对tensor进行就地修改</p></li><li><p>tensor和数字操作</p><pre class=" language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">97</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">+</span><span class="token number">10</span>Out<span class="token punctuation">[</span><span class="token number">97</span><span class="token punctuation">]</span><span class="token punctuation">:</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p>CUDA中的tensor</p><p>CUDA（Compute Unified Device Architecture），是NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</p><p><code>torch.cuda</code>这个模块增加了对CUDA tensor的支持，能够在cpu和gpu上使用相同的方法操作tensor</p><p>通过<code>.to</code>方法能够把一个tensor转移到另外一个设备(比如从CPU转到GPU)</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")</span><span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda"</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># cuda device对象</span>    y <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>x<span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 创建一个在cuda上的tensor</span>    x <span class="token operator">=</span> x<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true"># 使用方法把x转为cuda 的tensor</span>    z <span class="token operator">=</span> x <span class="token operator">+</span> y    <span class="token keyword">print</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>z<span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">"cpu"</span><span class="token punctuation">,</span> torch<span class="token punctuation">.</span>double<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># .to方法也能够同时设置类型</span>    <span class="token operator">>></span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.9806</span><span class="token punctuation">]</span><span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">'cuda:0'</span><span class="token punctuation">)</span><span class="token operator">>></span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.9806</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float64<span class="token punctuation">)</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> nlp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nlp </tag>
            
            <tag> pytorch </tag>
            
            <tag> tensor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-整数转罗马数字(medium)</title>
      <link href="/2020/04/21/Leetcode-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97-medium/"/>
      <url>/2020/04/21/Leetcode-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97-medium/</url>
      
        <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description"></a>Problem description</h3><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>示例 1:</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">3</span>输出<span class="token punctuation">:</span> <span class="token string">"III"</span></code></pre><p>示例 2:</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">4</span>输出<span class="token punctuation">:</span> <span class="token string">"IV"</span></code></pre><p>示例 3:</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">9</span>输出<span class="token punctuation">:</span> <span class="token string">"IX"</span></code></pre><p>示例 4:</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">58</span>输出<span class="token punctuation">:</span> <span class="token string">"LVIII"</span>解释<span class="token punctuation">:</span> L <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">,</span> V <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> III <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">.</span></code></pre><p>示例 5:</p><pre class=" language-python"><code class="language-python">输入<span class="token punctuation">:</span> <span class="token number">1994</span>输出<span class="token punctuation">:</span> <span class="token string">"MCMXCIV"</span>解释<span class="token punctuation">:</span> M <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">,</span> CM <span class="token operator">=</span> <span class="token number">900</span><span class="token punctuation">,</span> XC <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">,</span> IV <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">.</span></code></pre><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intToRoman</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        romans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"M"</span><span class="token punctuation">,</span> <span class="token string">"CM"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">,</span> <span class="token string">"CD"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"XC"</span><span class="token punctuation">,</span> <span class="token string">"L"</span><span class="token punctuation">,</span> <span class="token string">"XL"</span><span class="token punctuation">,</span> <span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"IX"</span><span class="token punctuation">,</span> <span class="token string">"V"</span><span class="token punctuation">,</span> <span class="token string">"IV"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">]</span>        index <span class="token operator">=</span> <span class="token number">0</span>        s <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">while</span> index <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> num <span class="token operator">>=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                s <span class="token operator">+=</span> romans<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                num <span class="token operator">-=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span>            index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> s</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-盛水最多的容器(medium)</title>
      <link href="/2020/04/18/Leetcode2/"/>
      <url>/2020/04/18/Leetcode2/</url>
      
        <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description"></a>Problem description</h3><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and n is at least 2.</p><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"></p><p>Example</p><pre class=" language-python"><code class="language-python">Input<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>Output<span class="token punctuation">:</span> <span class="token number">49</span></code></pre><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>可将问题视为面积最大化问题，即将长和宽最大化</p><ol><li><p>首先将左右两边作为起始点，左点索引值为l,右点索引值为r，底边长度为r-l,此时<br>底边长度为最大值</p></li><li><p>当左边的值小于右边的值时，面积为左边的值乘以底边，并且左边索引往右移动一位，即l+1</p></li></ol><p>反之，面积为右边的值乘以底边，并且右边索引往左移动一位，即r-1</p><ol start="3"><li>比较每次的面积area, if area &gt; maxArea, 则maxArea = area</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        maxArea <span class="token operator">=</span> <span class="token number">0</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        l <span class="token operator">=</span> <span class="token number">0</span>         r <span class="token operator">=</span> length        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                area <span class="token operator">=</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span>                r <span class="token operator">=</span> r<span class="token number">-1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                area <span class="token operator">=</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span>                l <span class="token operator">=</span> l<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">if</span> area <span class="token operator">></span> maxArea<span class="token punctuation">:</span>                maxArea <span class="token operator">=</span> area                    <span class="token keyword">return</span> maxArea</code></pre><p><img src="/image/download1.png"><br><img src="/image/download2.png"><br><img src="/image/download3.png"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-回文数(easy)</title>
      <link href="/2020/04/16/Leetcode-palindrome-number-easy/"/>
      <url>/2020/04/16/Leetcode-palindrome-number-easy/</url>
      
        <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description"></a>Problem description</h3><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p>Example 1:</p><pre class=" language-python"><code class="language-python">Input<span class="token punctuation">:</span> <span class="token number">121</span>Output<span class="token punctuation">:</span> true</code></pre><p>Example 2:</p><pre class=" language-python"><code class="language-python">Input<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">121</span>Output<span class="token punctuation">:</span> false</code></pre><p>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.<br>Example 3:</p><pre class=" language-python"><code class="language-python">Input<span class="token punctuation">:</span> <span class="token number">10</span>Output<span class="token punctuation">:</span> false</code></pre><p>Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>成对比较头尾对应index的字符是否相等即可</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>    <span class="token keyword">if</span> x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>             <span class="token keyword">return</span> <span class="token boolean">False</span>        x <span class="token operator">=</span> str<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>int<span class="token punctuation">(</span>l<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">is</span> <span class="token operator">not</span> x<span class="token punctuation">[</span>l<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span></code></pre><p>不将整数转换成字符串的方法：<br>通过求余数的方法将整数进行反转，并将反转后的数字与原输入进行对比：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        temp<span class="token operator">=</span>x        rev<span class="token operator">=</span><span class="token number">0</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            digit<span class="token operator">=</span>x<span class="token operator">%</span><span class="token number">10</span>            rev<span class="token operator">=</span>rev<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>digit            x<span class="token operator">=</span>x<span class="token operator">//</span><span class="token number">10</span>        <span class="token keyword">if</span> temp<span class="token operator">==</span>rev<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cnn训练恶评区分模型</title>
      <link href="/2019/11/15/cnn%E8%AE%AD%E7%BB%83%E6%81%B6%E8%AF%84%E5%8C%BA%E5%88%86%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/11/15/cnn%E8%AE%AD%E7%BB%83%E6%81%B6%E8%AF%84%E5%8C%BA%E5%88%86%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3>训练集</h3><p>数据集包含大量来自wikipedia的恶评，并且被分类为以下6个标签：</p><ul><li><code>toxic</code></li><li><code>severe_toxic</code></li><li><code>obscene</code></li><li><code>threat</code></li><li><code>insult</code></li><li><code>identity_hate</code></li><li>创建一个模型来预测每个恶评在每种标签的可能性。</li></ul><h3>基本参数</h3><p>MAX_SEQUENCE_LENGTH = 100<br> MAX_VOCAB_SIZE = 20000<br> EMBEDDING_DIM = 100       #embedding dimenstion<br> VALIDATION_SPLIT = 0.2<br> BATCH_SIZE = 128<br> EPOCHS = 10</p><p>读取golve做的词向量预训练的结果.word2vec 是通过glove预训练词向量构造的一个字典，每个单词都有一个对应的100维度的词向量,词向量来源于glove的预训练。</p><!-- wp:code --><pre class="wp-block-code"><code>word2vec = &#123;&#125;with open('D://software engineering/nlp_translate/glove.6B.100d.txt','r',encoding='utf-8') as f:    for line in f:        values = line.split()    word = values[0]    vec = np.asarray(values[1:], dtype='float32')    word2vec[word] = vecprint('Found %s word vectors.' % len(word2vec))</code></pre><!-- /wp:code --><!-- wp:paragraph {"align":"left"} --><p style="text-align:left">使用keras库里的文本和序列预处理的库,Tokenizer是一个用于向量化文本，或将文本转换为序列的类。</p><!-- /wp:paragraph --><!-- wp:code --><pre class="wp-block-code"><code>train = pd.read_csv("D:/software engineering/nlp_translate/train.csv")sentences  =train["comment_text"].fillna("DUMMY_VALUE").valuespossible_lables = ["toxic","severe_toxic","obscene","threat","insult","identity_hate"]targets = train[possible_lables].valuesprint("max sequence length:",max(len(s) for s in sentences))print("min sequence length:", min(len(s)for s in sentences))s=sorted(len(s) for s in sentences)print("median sequence length:", s[len(s)//2])#convert the sentences into integerstokenizer = Tokenizer(num_words = MAX_VOCAB_SIZE)tokenizer.fit_on_texts(sentences)sequences = tokenizer.texts_to_sequences(sentences)word2idx = tokenizer.word_indexprint('Found %s unique tokens.' %len(word2idx))data = pad_sequences(sequences,maxlen = MAX_SEQUENCE_LENGTH)print('Shape of data tensor:', data.shape)</code></pre><!-- /wp:code --><!-- wp:paragraph --><p>利用train中的comment_text数据，先造了一个字典word2idx，每个单词都有一个对应的下标序号，texts_to_sequences()的作用则是构造了一个list,list的数字来源于word_index这个字典。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>如：单词nonsense，word2idx.get("nonsense")就是等于845。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>pad_seq则是在sequences的基础上进行了填充，填充至100,这样每个sequences的维度就一样了。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>构造一个embedding_matrix，只取了排名靠前的2W单词，并且把词向量填充进embedding_matrix。</p><!-- /wp:paragraph --><!-- wp:code --><pre class="wp-block-code"><code>num_words = min(MAX_VOCAB_SIZE, len(word2idx) + 1)embedding_matrix = np.zeros((num_words, EMBEDDING_DIM))for word, i in word2idx.items():  if i &lt; MAX_VOCAB_SIZE:    embedding_vector = word2vec.get(word)    if embedding_vector is not None:      # words not found in embedding index will be all zeros.      embedding_matrix[i] = embedding_vector</code></pre><!-- /wp:code --><!-- wp:paragraph --><p>将这个词向量矩阵加载到Embedding层中，设置trainable=False使得这个编码层不可再训练。如果输入数据不需要词的语义特征，简单使用Embedding层就可以得到一个对应的词向量矩阵，但如果需要语义特征，就需要把glove预训练好的词向量扔到Embedding层中。</p><!-- /wp:paragraph --><!-- wp:code --><pre class="wp-block-code"><code>embedding_layer = Embedding(  num_words,  EMBEDDING_DIM,  weights=[embedding_matrix],  input_length=MAX_SEQUENCE_LENGTH,  trainable=False)</code></pre><!-- /wp:code --><!-- wp:paragraph --><p>构造训练模型：</p><!-- /wp:paragraph --><!-- wp:code --><pre class="wp-block-code"><code>input_ = Input(shape=(MAX_SEQUENCE_LENGTH,))x = embedding_layer(input_)x = Conv1D(128, 3, activation='relu')(x)x = MaxPooling1D(3)(x)x = Conv1D(128, 3, activation='relu')(x)x = MaxPooling1D(3)(x)x = Conv1D(128, 3, activation='relu')(x)x = GlobalMaxPooling1D()(x)x = Dense(128, activation='relu')(x)output = Dense(len(possible_lables), activation='sigmoid')(x)model = Model(input_, output)model.compile(loss='binary_crossentropy',optimizer='rmsprop',metrics=['accuracy'])print('Training model...')r = model.fit(data,targets,batch_size=BATCH_SIZE,epochs=EPOCHS,validation_split=VALIDATION_SPLIT)</code></pre><!-- /wp:code --><!-- wp:heading {"level":3} --><h3>结果</h3><!-- /wp:heading --><p><img src="/image/t1.PNG"><br><img src="/image/t2.PNG"></p><!-- wp:paragraph --><p>代码地址：https://github.com/Dennis174698/toxic</p><!-- /wp:paragraph -->]]></content>
      
      
      <categories>
          
          <category> nlp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nlp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word2Vec</title>
      <link href="/2019/11/03/Word2Vec/"/>
      <url>/2019/11/03/Word2Vec/</url>
      
        <content type="html"><![CDATA[<!-- wp:paragraph --><p>Word2Vec是使用浅层神经网络学习词嵌入的最流行技术之一。它是由Tomas Mikolov于2013年在Google上开发的。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>当使用one-hot 编码并将其可视化时，将其想象为一个多维空间，其中每个单词占据一个维，而与其余单词无关（沿着其他维没有投影）。这意味着词与词之间没有任何关联性，这是不正确的。我们的目标是使上下文相似的单词占据紧密的空间位置。在数学上，此类向量之间的角度的余弦值应接近1，即角度应接近0。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>为此引入了一个单词对其他单词的某种依赖性。在该词的上下文中的词将在这种依赖性中获得更大的份额。Word2Vec是一种构造此类嵌入的方法，有两种方法（都涉及神经网络）来获得它：CBOW（Commom Bag of Words） 和 skipgram</p><!-- /wp:paragraph --><!-- wp:heading --><h2>CBOW:</h2><!-- /wp:heading --><!-- wp:paragraph --><p>此方法将每个单词的上下文作为输入，并尝试预测与上下文相对应的单词。考虑我以下例子：Have a great day<br> 将 great 作为input 输入到神经网络。使用单个上下文输入单词great预测目标单词  day。更具体地说，使用输入字词的 one-hot coding，并与目标字词的 one-hot coding 相比，测量输出误差。在预测目标词的过程中，学习目标词的向量表示。</p><!-- /wp:paragraph --><p><img src="/image/w2v1.PNG"></p><!-- wp:paragraph --><p>输入词是一个大小为V的热编码矢量。隐藏层包含N个神经元，输出是V长度矢量，其元素为softmax值。Wvn是将输入x映射到隐藏层的权重矩阵（V * N维矩阵).Wnv是将隐藏层输出映射到最终输出层的权重矩阵（N * V维矩阵）。隐藏层神经元仅将输入的加权总和复制到下一层。没有像sigmoid，tanh或ReLU这样的激活函数。唯一的非线性是输出层中的softmax计算。以上模型使用单个词来预测目标。也可以使用多个词来做同样的事情。</p><!-- /wp:paragraph --><p><img src="/image/w2v2.PNG"></p><!-- wp:paragraph --><p>上面的模型采用C个词。当Wvn用于计算隐藏层输入时，我们对所有这些C上下文词输入取平均值。<br> 还有另一种方法可以做到这一点。我们可以使用目标词（我们要生成其表示形式）来预测上下文，并在此过程中生成表示形式。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>Skip Gram</h2><!-- /wp:heading --><p><img src="/image/w2v3.PNG"></p><!-- wp:paragraph --><p> 将目标词输入网络。该模型输出C个概率分布。<br> 对于每个context 位置，我们获得V个概率的C个概率分布，每个单词一个。<br> 在这两种模型下，网络都使用反向传播进行学习。</p><!-- /wp:paragraph -->]]></content>
      
      
      <categories>
          
          <category> nlp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nlp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP之WordEmbedding</title>
      <link href="/2019/11/01/NLP%E4%B9%8BWordEmbedding/"/>
      <url>/2019/11/01/NLP%E4%B9%8BWordEmbedding/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> nlp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nlp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Dijkstra算法，MPI并行编程解决全源最短路径问题（All-Pairs Shortest Paths Problem)</title>
      <link href="/2019/10/24/%E4%BD%BF%E7%94%A8Dijkstra%E7%AE%97%E6%B3%95%EF%BC%8CMPI%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%EF%BC%88All-Pairs-Shortest-Paths-Problem/"/>
      <url>/2019/10/24/%E4%BD%BF%E7%94%A8Dijkstra%E7%AE%97%E6%B3%95%EF%BC%8CMPI%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%EF%BC%88All-Pairs-Shortest-Paths-Problem/</url>
      
        <content type="html"><![CDATA[<!-- wp:paragraph --><p>该项目的目标是设计并行算法，并使用Dijkstra算法来解决全源最短路径问题（All-Pairs Shortest Paths Problem) 。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p><a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">Dijkstra算法</a><br><a href="https://en.wikipedia.org/wiki/Message_Passing_Interface">mpi</a>  </p><!-- /wp:paragraph --><!-- wp:paragraph --><p>全源最短路径问题： 确定给定图中每对顶点之间的最短图形距离。<br>在全源最短路径问题中，每个顶点到所有顶点的最短距离可以分别计算。因此，MPI框架可用于并行计算最短距离，每个进程负责一部分顶点计算。根据顶点数量和平行比例平均分配所有顶点。在每个进程中，根据当前进程号和进程总数确定每个进程的计算范围。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>首先，程序在根进程中读取图形的输入数据，并通过MPI_Bcast函数将图形的顶点数和权重矩阵分配给每个进程。为了方便处理，将图的数据读入并存储在一维数组中。接下来，在每个过程中，使用djkstra算法计算从每个顶点到范围内所有顶点的最短距离。计算完成后，通过MPI_Gatherv函数将每个进程的计算结果收集到根进程中，最后将结果保存到根进程中的文件中。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>部分代码</h2><!-- /wp:heading --><!-- wp:paragraph --><p>djkstra algorithm 的实现</p><!-- /wp:paragraph --><!-- wp:code --><pre class="wp-block-code"><code>/** * Using djkstra algorithm to calculate the shortest distance between vertices * * @param graph Graph struct * @param start start number of the vertex that calculates the shortest distance * @param end end number of the vertex that calculates the shortest distance * @return */int *djstra(Graph *graph, int start, int end) &#123;    int n = graph->vertices_number;    int *local_result = (int *) malloc(sizeof(int) * (end - start + 1) * n);    memcpy(local_result, graph->adjacency_matrix + start * n, (end - start + 1) * n * sizeof(int));    int *mark = (int *) malloc(sizeof(int) * n);    int vertex_no = start;    for (; vertex_no &lt;= end; vertex_no++) &#123;        memset(mark, 0, sizeof(int) * n);        int i = 0;        while (i++ &lt; n) &#123;            int offset = (vertex_no - start) * n;            int vertex = get_min(local_result + offset, mark, n);            mark[vertex] = 1;            int j = 0;            for (; j &lt; n; j++) &#123;                if (mark[j] == 1) &#123;                    continue;                &#125;                // updating distance                if (local_result[offset + vertex] + graph->adjacency_matrix[vertex * n + j] &lt;local_result[offset + j]) &#123;                    local_result[offset + j] = local_result[offset + vertex] + graph->adjacency_matrix[vertex * n + j];                &#125;            &#125;        &#125;    &#125;    return local_result;&#125;</code></pre><!-- /wp:code --><p><img src="/image/Dijkstra_Animation.gif"></p><!-- wp:paragraph --><p>连续迭代，每次找到距离最短的顶点，更新从该顶点到其他顶点的距离，直到找到到所有顶点到起点的最短距离。这是使用Dijkstra 单源最短路径算法，将此函数broadcast到MPI的其他节点，并分配给其相应的图中的顶点并完成此算法，就可以解决全源最短路径问题。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>输入文件</h2><!-- /wp:heading --><!-- wp:paragraph --><p>输入文件格式本质上是有向加权图的扁平邻接矩阵。所有权重均为正整数。这些是二进制文件，因此需要将其读取。每个文件包含：</p><!-- /wp:paragraph --><!-- wp:list --><ul><li>顶点数 (numV)</li><li>numV x numV 个整数，指定所有连接的权重<br>例如：<br></li></ul><!-- /wp:list --><p><img src="/image/graph.PNG"></p><!-- wp:paragraph --><p>对应如下矩阵：</p><!-- /wp:paragraph --><p><img src="/image/matirx.PNG"></p><!-- wp:heading --><h2>使用</h2><!-- /wp:heading --><!-- wp:paragraph --><p><code>./run.sh</code>  host 文件定义了MPI 所需要的节点数量，最优使用数量在16个左右</p><!-- /wp:paragraph --><!-- wp:heading --><h2>输出</h2><!-- /wp:heading --><!-- wp:paragraph --><p><code>./print_bin_result test_data/xxx.out</code></p><!-- /wp:paragraph --><!-- wp:paragraph --><p>项目地址：<a href="https://github.com/Dennis174698/dijkstra_mpi">https://github.com/Dennis174698/dijkstra_mpi</a><br></p><!-- /wp:paragraph -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ardunio nano 开发自动小船</title>
      <link href="/2019/10/13/%E4%BD%BF%E7%94%A8arduino-%E5%BC%80%E5%8F%91%E8%87%AA%E5%8A%A8%E5%B0%8F%E8%88%B9/"/>
      <url>/2019/10/13/%E4%BD%BF%E7%94%A8arduino-%E5%BC%80%E5%8F%91%E8%87%AA%E5%8A%A8%E5%B0%8F%E8%88%B9/</url>
      
        <content type="html"><![CDATA[<!-- wp:heading --><h2>功能</h2><!-- /wp:heading --><!-- wp:list --><ul><li>通过指南针模块反馈保持直行</li><li>碰到障碍物时掉头</li><li>掉头后保持直行</li><li>返回到起始点</li></ul><!-- /wp:list --><!-- wp:heading {"level":3} --><h3>器件清单</h3><!-- /wp:heading --><!-- wp:list --><ul><li>Arduino Nano x 1; </li><li>Boat cover x 1; </li><li>Battery case x 1; </li><li>1.5v Battery x 4; </li><li>Breadboard x 1; </li><li>LSM303 3 Axis Digital Compass sensor; </li><li>Z6322 Ultrasonic Distance Sensor;</li><li>Eletric motor x2 ; </li></ul><!-- /wp:list --><!-- wp:heading {"level":3} --><h3>硬件设置</h3><!-- /wp:heading --><p><img src="/image/hardware.PNG"></p><p><img src="/image/ebd.png"></p><!-- wp:heading {"level":3} --><h3>程序逻辑</h3><!-- /wp:heading --><p><img src="/image/workflow.PNG"></p><!-- wp:heading {"level":4} --><h4>指南针模块的读取：</h4><!-- /wp:heading --><!-- wp:paragraph --><p>要将microTesla读数转换为0-360度指南针航向，需要使用atan2（）函数计算由Y和X轴读数定义的矢量的角度。结果将以弧度为单位，因此我们乘以180度，然后除以Pi以将其转换为度。同时加上360度将范围定在0到360度之间。</p><!-- /wp:paragraph --><!-- wp:code --><pre class="wp-block-code"><code>float compassRead(float heading)&#123;  /* Get a new sensor event */   sensors_event_t   event;   mag.getEvent(&amp;event);    float Pi = 3.14159;    // Calculate the angle of the vector y,x  heading = (atan2(event.magnetic.y,event.magnetic.x) * 180) / Pi;// 计算arctan（x，y）    // Normalize to 0-360  if (heading &lt; 0)  &#123;    heading = 360 + heading;  &#125;  return heading;&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":4} --><h4>超声波距离传感器模块的读取：</h4><!-- /wp:heading --><!-- wp:paragraph --><p>给Trig发送一个低高低的短时间脉冲,触发测距,存储回波等待时间,pulseIn函数会等待引脚变为HIGH,开始计算时间,再等待变为LOW并停止计时,等待返回脉冲的长度。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>声速是:340m/1s 换算成 34000cm / 1000000μs =&gt; 34 / 1000<br>因为发送到接收,实际是相同距离走了2回,所以要除以2<br> 距离(厘米)  =  (回波时间 * (34 / 1000)) / 2<br> 简化后的计算公式为 (回波时间 * 17)/ 1000 cm</p><!-- /wp:paragraph --><!-- wp:code --><pre class="wp-block-code"><code>void distance()&#123;  digitalWrite(Trig, LOW);   delayMicroseconds(2);      digitalWrite(Trig,HIGH);   delayMicroseconds(10);      digitalWrite(Trig, LOW);     temp = float(pulseIn(Echo, HIGH));   //calculte the time between HIGH to LOW      //34000cm / 1000000μs => 34 / 1000  //  //distance(cm)  =  (temp * (34 / 1000)) / 2  // (temp * 17)/ 1000    cm = (temp * 17 )/1000; //transfer to cm&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":4} --><h4>servo转向角度:</h4><!-- /wp:heading --><!-- wp:paragraph --><p>转向角度=初始角度-实时角度<br>特殊情况1：<br>船身角度330°转到30°，转向角度=实时角度-初始角度：30°-330°+360° = 60°<br>Servo偏向等于90°+60°=150°<br>特殊情况2：<br>船身角度30°转到330°，转向角度=初始角度-实时角度：30°-330°+360° = 60°<br>Servo偏向等于90°-60° = 30°</p><!-- /wp:paragraph --><p><img src="/image/angle.PNG"></p><!-- wp:code --><pre class="wp-block-code"><code>    turnAngle = int(init_angle)-int(angle);    if(turnAngle>180)&#123;      turnAngle = int(angle)-int(init_angle)+360;      servoValue = 90+turnAngle;    &#125;    else if(turnAngle&lt;=-180)&#123;       turnAngle+=360;       servoValue = 90-turnAngle;    &#125;    else if(turnAngle>-180&amp;&amp;turnAngle&lt;180)    &#123;      servoValue = 90-turnAngle;    &#125;</code></pre><!-- /wp:code --><!-- wp:paragraph --><p>servo 会控制船舵偏向，从而达到控制船身前进方向的效果。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>项目地址： <a href="https://github.com/Dennis174698/auto_boat">https://github.com/Dennis174698/auto_boat</a></p><!-- /wp:paragraph -->]]></content>
      
      
      <categories>
          
          <category> 杂技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slitherlink puzzle game</title>
      <link href="/2019/05/15/slitherlink-puzzle-game/"/>
      <url>/2019/05/15/slitherlink-puzzle-game/</url>
      
        <content type="html"><![CDATA[<!-- wp:heading {"level":1} --><h1>slitherlink</h1><!-- /wp:heading --><!-- wp:paragraph --><p><a href="https://en.wikipedia.org/wiki/Slitherlink">slitherlink game</a>:</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>数回：游戏由0,1,2,3四个数字组成。每一个数字，代表四周划线的数目，并在最后成为一个不间断<br> 、不分岔的回路。<br> 把点与点以直线和横线相连，使之成为一个回路，且只能有一个回路。四点之间的数字代表在其四周的线的数目。<br> 在没有数字的地方，划线的数目没有任何限制，而0的四周则不能有任何划线。路线不能交叉，也不能有分岔。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p><br></p><!-- /wp:paragraph --><!-- wp:heading --><h2>Run</h2><!-- /wp:heading --><!-- wp:paragraph --><p>Run.java</p><!-- /wp:paragraph --><!-- wp:heading --><h2>samples</h2><!-- /wp:heading --><!-- wp:image --><figure class="wp-block-image"><img src="https://github.com/Dennis174698/slitherlink/raw/master/1.PNG" alt=""/></figure><!-- /wp:image --><!-- wp:paragraph --><p>点击finish 检测是否完成游戏</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>finished ：完成游戏   wrong number ：数字周围边数错误 dangling end: 未完成回路 branching line ：回路有分岔 disconnected line： 有未连接的线</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>项目地址：https://github.com/Dennis174698/slitherlink</p><!-- /wp:paragraph -->]]></content>
      
      
      <categories>
          
          <category> 杂技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蚁群算法在旅行商问题的应用</title>
      <link href="/2018/10/20/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95%E5%9C%A8%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2018/10/20/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95%E5%9C%A8%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>Applying Ant Colony Optimisation to the Travelling Salesman Problem</h1><h2>problem description</h2><p>旅行推销员问题：如果旅行推销员希望精确访问一次m个城市列表中的每个城市（其中，从城市i到城市j的旅行成本为cij），然后返回到本国城市，可能的最短路径是多少。</p><h2>Algorithm</h2><figure class="wp-block-image"><img src="https://github.com/Dennis174698/TSP/raw/master/aco.png" alt=""/></figure><p style="font-size:27px">Ant Colony Optimization</p><p>ACO算法基于蚂蚁的行为，尝试寻找两点之间的最佳路径。</p><p>这是通过发送大量蚂蚁波来遍历图形来实现的。第一波蚂蚁随机地或基于一种简单的启发式方法（例如从任何节点走最短路径）遍历该图。</p><p>然后，信息素会沿着成功的路径分布，那些通过评分函数确定为相对较好的路径将接收更多量的信息素。然后，将进一步的蚂蚁发送出去遍历图，同时考虑信息素的水平和启发式，然后再次将信息素放置在与路径得分成比例的路径上。</p><p>这样，最优化的路径将累积最多量的信息素，并且更有可能被后代的蚂蚁选择。</p><p><br></p><h2>Implementation</h2><figure class="wp-block-image"><img src="https://github.com/Dennis174698/TSP/raw/master/workflow1.png" alt=""/></figure><p> <br>   迭代阶段涉及迭代一定数量的世代，并在每次迭代中执行以下操作： <br></p><ol><li>为每个蚂蚁生成一条路线。该路线由以下步骤生成：<br><br> <strong>a. </strong>随机选择一个起点<br><br> <strong>b. </strong>根据信息素图和启发式因素的组合选择下一个要访问的位置。具体来说，使用以下公式为每个未访问的位置评分： <br> <code>𝑠𝑐𝑜𝑟𝑒 = 𝑝ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒𝛼**α ∗ ℎ𝑒𝑢𝑟𝑖𝑠𝑡𝑖𝑐**β</code> 同时:  <code>𝑝ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒</code> = 从当前位置到未访问位置的路径上的信息素数量。<br><br> <code>α</code> = 信息素权重影响的比例因子。 <br><br> <code>ℎ𝑒𝑢𝑟𝑖𝑠𝑡𝑖𝑐</code> = 从当前位置到未访问位置的启发式值（在此解决方案中为1 /距离）。<br><br> <code>β</code> = 启发值权重影响的比例因子.<br><br> c. 将下一个位置添加到路线并将其从未访问位置列表中删除。<br></li><li>根据行进的总距离对路线进行评分。       <code>(cost= fun.decodingFun(RouteData,popsize,dmat,N))</code><br></li><li>当找到更好的路线，将bestsolution更新<br></li><li>将分数标准化到 [100, 200]。<br></li><li>生成信息素图，以沿着蚂蚁的路线分布。该值由路径上每条路径的信息素<code>𝑞 / 𝑠𝑐𝑎𝑙𝑒𝑑 𝑠𝑐𝑜𝑟𝑒</code>决定，其中q是某个比例因子<br></li><li>衰减现有信息素并使用以下公式添加所需的新信息素：<br><code>𝑝ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒 = 𝑐𝑢𝑟𝑟𝑒𝑛𝑡𝑃ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒 ∗ (1 − ⍴) + 𝑛𝑒𝑤𝑃ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒(Tau=Tau*(1-rho)+detaTau)</code><br><code>𝑝ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒</code> = 更新后的信息素值<br><code>𝑐𝑢𝑟𝑟𝑒𝑛𝑡𝑃ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒</code> = 在这条路线上现有的信息素值<br><code>⍴ </code>=信息素衰减因子.<br><code>𝑛𝑒𝑤𝑃ℎ𝑒𝑟𝑜𝑚𝑜𝑛𝑒</code> = 根据路线分数添加的信息素.<br></li></ol>><p>所有迭代完成后， 将会得到：</p><ol><li>最优路线</li><li>每次迭代的最优分数</li><li>在每次迭代中所有路线分数的总和</li></ol><p style="font-size:29px">Sample Result:</p><p>预设值</p><p>MaxGen=100 #Iteration<br> popsize=20 #population of ants<br> alpha=4    #α<br> beta=1     #β<br> rho=0.5    #ρ<br> Q=5        #q</p><p><img src="/image/1.png"></p><p><img src="/image/2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
